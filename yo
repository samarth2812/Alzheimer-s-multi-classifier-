import {
  Drawer,
  IconButton,
  Tooltip,
  Box,
  Typography,
  TextField,
  InputAdornment,
  Button,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogContentText,
  DialogActions,
} from "@mui/material";
import { useCallback, useEffect, useMemo, useState } from "react";
import VisibilityIcon from "@mui/icons-material/Visibility";
import ArrowBackIcon from "@mui/icons-material/ArrowBack";
import AddIcon from "@mui/icons-material/Add";
import { Delete, GetApp, Search } from "@mui/icons-material";

import DataTable from "examples/Tables/DataTable";
import MDTypography from "components/MDTypography";
import { animatedButtonStyle, iconButtonStyle, topBarSearchStyle, topBarStyle } from "./styles";
import CustomIconButton from "./CustomIconButton";
import { formatDateTime } from "pages/IndentManagement/helper";
import { apiRequest } from "../../axios/apiRequest";
import toast, { LoaderIcon } from "react-hot-toast";
import EmptyStateBox from "./emptyStateBox";
import { BsTable } from "react-icons/bs";
import debounce from "lodash.debounce";
import PaginationFooter from "./PaginationFooter";

export const AttachmentDrawer = ({
  moduleId,
  module,
  uploadedBy,
  uploadedByRole,
  attachments = [],
  open,
  onClose,
  onUploadComplete,
  user,
  isHidden = false,
}) => {
  const [mode, setMode] = useState("table");
  const [selectedFile, setSelectedFile] = useState(null);
  const [previewUrl, setPreviewUrl] = useState(null);
  const [loading, setLoading] = useState(null);
  const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false);
  const [attachmentToDelete, setAttachmentToDelete] = useState(null);
  const [searchTerm, setSearchTerm] = useState("");
  const [filteredData, setFilteredData] = useState([]);

  // Pagination state
  const [currentPage, setCurrentPage] = useState(1);
  const [rowsPerPage, setRowsPerPage] = useState(5);
  const [totalRecords, setTotalRecords] = useState(1);
  const [totalPages, setTotalPages] = useState(1);

  // Debounced filter function
  const debouncedFilter = useMemo(() => {
    return debounce((term, data) => {
      const filtered = data.filter((item) => {
        const lowerTerm = term.toLowerCase();
        const normalizedTerm = lowerTerm.replace(/[^a-z0-9]/gi, "");

        return Object.values(item).some((value) => {
          if (!value) return false;

          const stringVal = value.toString().toLowerCase();
          const cleanedVal = stringVal.replace(/[^a-z0-9]/gi, "");

          return (
            stringVal.includes(lowerTerm) || // Standard check
            cleanedVal.includes(normalizedTerm) || // Normalized for hyphens, etc.
            stringVal.replace(/\D/g, "").includes(term.replace(/\D/g, "")) // Only numeric
          );
        });
      });

      setFilteredData(filtered);
    }, 300);
  }, []);

  useEffect(() => {
    const normalizeSearchTerm = (term) => {
      const mappings = {
        "COMPLIANCE MAKER": "COMPLIANCE_MAKER",
        "COMPLIANCE CHECKER": "COMPLIANCE_CHECKER",
        "DEPARTMENT MAKER": "DEPARTMENT_MAKER",
        "DEPARTMENT CHECKER": "DEPARTMENT_CHECKER",
      };
      const lowerTerm = term.toLowerCase().trim();
      if (!lowerTerm) return ""; // Return empty string if nothing is typed
      // Exact match
      if (mappings[lowerTerm]) {
        return mappings[lowerTerm];
      }
      // Partial match
      for (const [key, value] of Object.entries(mappings)) {
        if (key.startsWith(lowerTerm) || lowerTerm.includes(key)) {
          return value;
        }
      }
      return lowerTerm;
    };
    const normalizedTerm = normalizeSearchTerm(searchTerm);
    setFilteredData([]);

    if (!normalizedTerm) {
      // If search bar is empty, show all data
      setFilteredData(attachments);
    } else {
      debouncedFilter(normalizedTerm, attachments);
    }

    return () => debouncedFilter.cancel();
  }, [searchTerm, attachments, debouncedFilter]);

  useEffect(() => {
    if (open) {
      setMode("table");
      setPreviewUrl(null);
      setSelectedFile(null);
    }
  }, [open]);
  const handleSearch = (event) => {
    setSearchTerm(event.target.value);
  };
  const deleteConfirmationDialog = (
    <Dialog
      open={isDeleteDialogOpen}
      onClose={() => setIsDeleteDialogOpen(false)}
      PaperProps={{
        sx: {
          borderRadius: 4,
          backdropFilter: "blur(40px)",
          bgcolor: (theme) => theme.palette.custom.zeroBlur,
          border: 2,
          borderColor: (theme) => theme.palette.custom.zeroBlur,
          boxShadow: 24,
          p: 2,
        },
      }}
    >
      <DialogTitle sx={{ color: (theme) => theme.palette.custom.two, fontSize: "1rem !important" }}>
        Delete Attachment
      </DialogTitle>
      <DialogContent>
        <DialogContentText
          sx={{ color: (theme) => theme.palette.custom.text2, fontSize: "0.7rem !important" }}
        >
          Are you sure you want to delete <strong>this attachment</strong>?
        </DialogContentText>
      </DialogContent>
      <DialogActions>
        <Button
          size="small"
          onClick={() => setIsDeleteDialogOpen(false)}
          sx={{
            color: (theme) => theme.palette.custom.two,
            fontSize: "0.7rem !important",
            transition: "all 0.3s ease",
            "&:hover": {
              bgcolor: (theme) => theme.palette.custom.two,
              color: (theme) => theme.palette.custom.light,
            },
            px: 3,
            py: 1,
            borderRadius: 10,
            width: "80px",
          }}
        >
          Cancel
        </Button>
        <Button
          size="small"
          onClick={async () => {
            try {
              const response = await apiRequest(
                "DELETE",
                `${process.env.REACT_APP_BACKEND_URL}/api/v1/attachment/delete-document/${attachmentToDelete}`
              );

              if (response.status === 200) {
                toast.success("Document deleted successfully");
                if (onUploadComplete) onUploadComplete();
              } else {
                toast.error("Failed to delete document");
              }
            } catch (err) {
              console.error("Delete failed", err);
              toast.error("Failed to delete document");
            } finally {
              setIsDeleteDialogOpen(false);
            }
          }}
          sx={{
            bgcolor: (theme) => theme.palette.custom.one,
            color: (theme) => theme.palette.custom.two,
            transition: "all 0.3s ease",
            fontSize: "0.7rem !important",
            "&:hover": {
              bgcolor: (theme) => theme.palette.custom.two,
              color: (theme) => theme.palette.custom.light,
            },
            px: 2,
            py: 1,
            borderRadius: 10,
          }}
        >
          Delete
        </Button>
      </DialogActions>
    </Dialog>
  );

  const handleFileView = async (attachmentId) => {
    try {
      const response = await apiRequest(
        "GET",
        `${process.env.REACT_APP_BACKEND_URL}/api/v1/attachment/fetch-document/${attachmentId}`
      );
      setPreviewUrl(response.data?.signedUrl);
    } catch {
      toast.error("Failed to fetch this Document");
    }
  };

  const handleFileDownload = async (attachmentId, fileName) => {
    try {
      const response = await apiRequest(
        "GET",
        `${process.env.REACT_APP_BACKEND_URL}/api/v1/attachment/fetch-document/${attachmentId}`
      );

      const signedUrl = response.data?.signedUrl;

      if (!signedUrl) {
        toast.error("Download URL not found");
        return;
      }

      // Fetch file as blob
      const fileResponse = await fetch(signedUrl);
      const blob = await fileResponse.blob();

      // Create object URL and trigger download
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = fileName;
      document.body.appendChild(a);
      a.click();
      a.remove();
      window.URL.revokeObjectURL(url);
    } catch (err) {
      console.error("Download failed", err);
      toast.error("Failed to download document");
    }
  };

  const handleFileUpload = async () => {
    try {
      if (!selectedFile) return;
      setLoading(true);

      const maxSizeMB = 30;
      if (selectedFile.size > maxSizeMB * 1024 * 1024) {
        toast.error(`File size exceeds ${maxSizeMB}MB`);
        return;
      }

      const uploadDocumentUrl = `${process.env.REACT_APP_BACKEND_URL}/api/v1/attachment/upload-document`;
      const formData = new FormData();
      formData.append("file", selectedFile);
      formData.append("module", module);
      formData.append("entityId", moduleId);
      formData.append("uploadedBy", uploadedBy);
      formData.append("uploadedByRole", uploadedByRole);

      const result = await apiRequest("POST", uploadDocumentUrl, formData);
      if (result.status === 200 || result.status === 204) {
        toast.success("Document Uploded Successfully");

        setSelectedFile(null);
        setMode("table");
      } else {
        toast.error("Error uploading Document. Try again Later");
      }
      if (onUploadComplete) onUploadComplete();
    } catch (error) {
      console.error("Error uploading Document:", error);
    } finally {
      setLoading(false);
    }
  };

  const formatTableData = (attachments) => {
    const columns = [
      { Header: "S.No", accessor: "serialNumber", width: "5%", align: "center" },
      { Header: "File Name", accessor: "fileName", width: "35%", align: "left" },
      { Header: "Uploaded By", accessor: "uploadedBy", width: "20%", align: "left" },
      { Header: "Date", accessor: "uploadDate", width: "20%", align: "center" },
      { Header: "Actions", accessor: "actions", width: "20%", align: "center" },
    ];

    const rows = attachments.map((item, index) => ({
      serialNumber: (
        <MDTypography variant="button" sx={{ fontSize: "0.7rem !important" }}>
          {index + 1}
        </MDTypography>
      ),
      fileName: (
        <MDTypography variant="button" sx={{ fontSize: "0.7rem !important" }}>
          {item.fileName}
        </MDTypography>
      ),
      uploadedBy: (
        <MDTypography variant="button" sx={{ fontSize: "0.7rem !important" }}>
          {item.uploadedBy} ({item.uploadedByRole.replace(/_/g, " ")})
        </MDTypography>
      ),
      uploadDate: (
        <MDTypography variant="button" sx={{ fontSize: "0.7rem !important" }}>
          {formatDateTime(item.uploadedAt)}
        </MDTypography>
      ),
      actions: (
        <Box
          display="flex"
          gap={1}
          justifyContent="left"
          sx={{ color: (theme) => theme.palette.custom.text2 }}
        >
          <Tooltip title="View File">
            <IconButton
              onClick={() => {
                handleFileView(item.id);
                setMode("preview");
              }}
            >
              <VisibilityIcon
                fontSize="small"
                sx={{ color: (theme) => theme.palette.custom.text2, fontSize: "0.9rem !important" }}
              />
            </IconButton>
          </Tooltip>
          <Tooltip title="Download File">
            <IconButton onClick={() => handleFileDownload(item.id, item.fileName)} download>
              <GetApp
                fontSize="small"
                sx={{ color: (theme) => theme.palette.custom.text2, fontSize: "0.9rem !important" }}
              />
            </IconButton>
          </Tooltip>
          {user.role === item.uploadedByRole && user.email === item.uploadedBy && (
            <Tooltip title="Delete File">
              <IconButton
                onClick={() => {
                  setAttachmentToDelete(item.id);
                  setIsDeleteDialogOpen(true);
                }}
              >
                <Delete fontSize="small" />
              </IconButton>
            </Tooltip>
          )}
        </Box>
      ),
    }));

    return { columns, rows };
  };

  const paginatedData = useMemo(() => {
    const startIdx = (currentPage - 1) * rowsPerPage;
    const endIdx = startIdx + rowsPerPage;
    return filteredData.slice(startIdx, endIdx);
  }, [filteredData, currentPage, rowsPerPage]);

  useEffect(() => {
    setTotalRecords(filteredData.length);
    setTotalPages(Math.ceil(filteredData.length / rowsPerPage));
  }, [filteredData, rowsPerPage]);

  const handlePageChange = useCallback((event, newPage) => {
    setCurrentPage(newPage);
  }, []);

  const handleRowsPerPageChange = useCallback((event) => {
    const { numericValue, resetToFirstPage } = event;

    setRowsPerPage(numericValue);
    if (resetToFirstPage) {
      setCurrentPage(1);
    }
  }, []);

  const tableData = formatTableData(paginatedData);

  const renderHeaderTitle = () => {
    switch (mode) {
      case "upload":
        return "Upload Attachment";
      case "preview":
        return "Preview Attachment";
      default:
        return "Attachments";
    }
  };

  return (
    <>
      <Drawer
        anchor="bottom"
        open={open}
        onClose={onClose}
        PaperProps={{
          sx: {
            height: "90%",
            m: 0,
            width: "100%",
            maxWidth: "100vw",
            borderTopLeftRadius: 16,
            borderTopRightRadius: 16,
            borderBottomLeftRadius: 0,
            borderBottomRightRadius: 0,
            borderBottom: 0,
            px: 3,
            py: 2,
            backgroundColor: (theme) => theme.palette.custom.light,
          },
        }}
      >
        <Box
          sx={{
            width: "100%",
            height: "100%",
            display: "flex",
            flexDirection: "column",
            gap: "8px",
            position: "relative",
          }}
        >
          {/* Top Bar Header with dynamic title and back button */}
          <Box display="flex" alignItems="center" mb={2}>
            {mode !== "table" && (
              <IconButton onClick={() => setMode("table")}>
                <ArrowBackIcon />
              </IconButton>
            )}
            <Typography
              variant="h6"
              sx={{
                ml: mode !== "table" ? 1 : 0,
                color: (theme) => theme.palette.custom.two,
                fontSize: "0.9rem !important",
              }}
            >
              {renderHeaderTitle()}
            </Typography>
          </Box>

          {/* Main content */}
          <Box sx={{ flex: 1, overflowY: "auto" }}>
            {loading && (
              <>
                <Box
                  sx={{
                    width: "100%",
                    height: "60vh",
                    display: "flex",
                    justifyContent: "center",
                    alignItems: "center",
                    flexDirection: "column",
                    gap: 2,
                  }}
                >
                  <LoaderIcon style={{ width: "40px", height: "40px" }} />
                  <Typography variant="h6">Uploading document...</Typography>
                </Box>
              </>
            )}
            {mode === "upload" && !loading && (
              <>
                <Button
                  component="label"
                  sx={{
                    border: "2px dashed",
                    borderColor: (theme) => theme.palette.custom.text3,
                    height: "80%",
                    borderRadius: 2,
                    p: 4,
                    mt: 2,
                    textAlign: "center",
                    width: "100%",
                    cursor: "pointer",
                  }}
                >
                  <Typography variant="body2" color="text.secondary">
                    {selectedFile ? selectedFile.name : "Click to select a file to upload"}
                  </Typography>
                  <input
                    type="file"
                    hidden
                    onChange={(e) => setSelectedFile(e.target.files?.[0] || null)}
                  />
                </Button>
                <Typography
                  variant="caption"
                  sx={{
                    mt: 1,
                    color: (theme) => theme.palette.custom.text3,
                    fontSize: "0.65rem",
                    textAlign: "center",
                    display: "block",
                  }}
                >
                  {
                    "Allowed file types: .pdf, .xls, .xlsx, .jpg, .jpeg, .png, .eml, .msg — Max size: 30MB"
                  }
                </Typography>
                <Box display="flex" justifyContent="center" gap={2} mt={3} sx={{ width: "100%" }}>
                  <Box sx={{ width: "30%" }}>
                    <CustomIconButton
                      label="Upload"
                      onClick={handleFileUpload}
                      disabled={!selectedFile}
                    />
                  </Box>
                </Box>
              </>
            )}

            {mode === "table" && !loading && (
              <>
                <Box sx={{ ...topBarStyle, mb: 1, gap: 2 }}>
                  <TextField
                    fullWidth
                    placeholder="Search Attachments..."
                    variant="outlined"
                    sx={topBarSearchStyle}
                    value={searchTerm}
                    onChange={handleSearch}
                    InputProps={{
                      startAdornment: (
                        <InputAdornment position="start">
                          <Search fontSize="medium" sx={iconButtonStyle} />
                        </InputAdornment>
                      ),
                    }}
                  />
                  {!isHidden && (
                    <Button
                      size="small"
                      startIcon={<AddIcon />}
                      onClick={() => setMode("upload")}
                      color="info"
                      sx={animatedButtonStyle}
                    >
                      Upload
                    </Button>
                  )}
                </Box>
                {tableData && tableData?.rows && tableData?.rows.length > 0 ? (
                  <DataTable
                    table={tableData}
                    isSorted={false}
                    entriesPerPage={{ defaultValue: 5 }}
                    showTotalEntries={true}
                    noEndBorder
                  />
                ) : (
                  <EmptyStateBox
                    icon={BsTable}
                    title="Currently there are no Attachments"
                    description="Start a new indent by tapping the 'Upload' button "
                    height={"80%"}
                  />
                )}
                {!searchTerm && tableData && tableData?.rows && tableData?.rows.length > 0 && (
                  <PaginationFooter
                    currentPage={currentPage}
                    rowsPerPage={rowsPerPage}
                    totalPages={totalPages}
                    totalRecords={totalRecords}
                    onPageChange={handlePageChange}
                    onRowsPerPageChange={handleRowsPerPageChange}
                    loading={loading}
                  />
                )}
              </>
            )}
            {mode === "preview" && previewUrl && (
              <Box sx={{ border: "1px solid #ccc", height: "100%" }}>
                <iframe
                  src={previewUrl}
                  title="Attachment Preview"
                  width="100%"
                  height="98%"
                  style={{ border: "none" }}
                  onError={() => {
                    toast.error("Preview expired.Please try viewing again.");
                    setMode("table");
                  }}
                />
              </Box>
            )}
          </Box>
        </Box>
      </Drawer>
      {deleteConfirmationDialog}
    </>
  );
};
