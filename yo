export const createCommunication = async (data: CommunicationInput) => {
  try {
    const payload = buildCreatePayload(data);
    const newComm = await prisma.communication.create({ data: payload });

    // EMAIL NOTIFICATION: Send notification after successful workflow transition
    try {
      await sendCommNotification({
        commType: payload.commType,
        commsubject: payload.subject,
        sentTo: payload.sentTo,
        cc: payload?.cc,
        category: payload.category,
      });
    } catch (emailError: any) {
      // Email failure should not break the workflow
      console.error(`Email notification failed for Communication`, emailError);
    }

    return newComm;
  } catch (error) {
    console.error("Error creating communication:", error);
    throw new Error("Failed to create communication");
  }
};


export const addCommunication = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const communicationData = req.body;
    const communication = await createCommunication(communicationData);
    res.status(201).json(communication);
  } catch (error) {
    next(error);
  }
};



import crypto from "crypto";
import dayjs from "dayjs";
import bcrypt from "bcrypt";
import prisma from "../../db/connection";
import { ApiError } from "../../utils/ApiError";
import { User } from "@prisma/client";

export const sendResetToken = async (userId: number) => {
  const user = await prisma.user.findUnique({ where: { id: userId } });

  if (!user) throw ApiError.notFound(`User Not Found`);

  const rawToken = crypto.randomBytes(32).toString("hex");
  const hashedToken = crypto
    .createHash("sha256")
    .update(rawToken)
    .digest("hex");

  await prisma.user.update({
    where: { id: userId },
    data: {
      resetPasswordToken: hashedToken,
      resetPasswordTokenExpiry: dayjs().add(1, "hour").toDate(),
    },
  });

  const resetLink = `https://yourapp.com/create-password?token=${rawToken}`;

  //   await sendEmail(
  //     user.email,
  //     "Set Your Password",
  //     `<p>Click below to set your password:</p><a href="${resetLink}">${resetLink}</a>`
  //   );

  return {
    success: true,
  };
};

export const validateResetToken = async (rawToken: string) => {
  const hashed = crypto.createHash("sha256").update(rawToken).digest("hex");

  const user = await prisma.user.findFirst({
    where: {
      resetPasswordToken: hashed,
      resetPasswordTokenExpiry: { gte: new Date() },
    },
  });

  if (!user) throw ApiError.notFound(`Invalid or Expired Token`);
};

export const setNewPassword = async (token: string, newPassword: string, user: User) => {

  const hashed = crypto.createHash("sha256").update(token).digest("hex");

  const user = await prisma.user.findFirst({
    where: {
      resetPasswordToken: hashed,
      resetPasswordTokenExpiry: { gte: new Date() },
    },
  });

  if (!user)
    return res.status(400).json({ message: "Invalid or expired token" });

  const hashedPassword = await bcrypt.hash(newPassword, 10);

  await prisma.user.update({
    where: { id: user.id },
    data: {
      password: hashedPassword,
      resetPasswordToken: null,
      resetPasswordTokenExpiry: null,
    },
  });

  return res.status(200).json({ success: true });
};
