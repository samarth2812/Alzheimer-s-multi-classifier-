export const getIncidentAuditTrail = async (
  user: User,
  incidentId?: string,
  page: number = 1,
  pageSize: number = 10,
  filters?: {
    userRole?: string;
    actionType?: string;
    search?: string;
  }
) => {
  try {
    if (
      user.role !== "COMPLIANCE_MAKER" &&
      user.role !== "COMPLIANCE_CHECKER"
    ) {
      throw new Error("You are not authorized to view audit trails.");
    }

    const where: any = { AND: [] };

    if (incidentId) {
      where.AND.push({ incidentId });
    }

    if (filters?.userRole?.trim()) {
      where.AND.push({ role: filters.userRole.trim() });
    }

    if (filters?.actionType?.trim()) {
      where.AND.push({ actionType: filters.actionType.trim() });
    }

    if (filters?.search?.trim()) {
      const searchTerm = filters.search.trim();
      where.AND.push({
        OR: [
          { role: { contains: searchTerm, mode: "insensitive" } },
          { actionType: { contains: searchTerm, mode: "insensitive" } },
          { performedByName: { contains: searchTerm, mode: "insensitive" } },
          { performedByEmail: { contains: searchTerm, mode: "insensitive" } },
        ],
      });
    }

    const offset = (page - 1) * pageSize;

    const [auditEntries, total] = await Promise.all([
      prisma.incidentAuditTrail.findMany({
        where,
        skip: offset,
        take: pageSize,
        orderBy: { timestamp: "desc" },
        select: {
          incidentId: true,
          actionType: true,
          role: true,
          performedByName: true,
          performedByEmail: true,
          timestamp: true,
          modifications: true,
        },
      }),
      prisma.incidentAuditTrail.count({ where }),
    ]);

    return {
      success: true,
      data: auditEntries,
      pagination: {
        total,
        page,
        pageSize,
        totalPages: Math.ceil(total / pageSize),
      },
    };
  } catch (error) {
    console.error("Failed to fetch audit trail", error);
    throw new Error("Unable to fetch audit trail");
  }


export const getIndentAuditTrail = async (
  user: User,
  indentId?: string,
  page: number = 1,
  pageSize: number = 10,
  filters?: {
    userRole?: string;
    actionType?: string;
    search?: string;
  }
) => {
  try {
    if (
      user.role !== "COMPLIANCE_MAKER" &&
      user.role !== "COMPLIANCE_CHECKER"
    ) {
      throw new Error("You are not authorized to view audit trails.");
    }

    const where: any = { AND: [] };

    if (indentId) {
      where.AND.push({ indentId });
    }

    if (filters?.userRole?.trim()) {
      where.AND.push({ role: filters.userRole.trim() });
    }

    if (filters?.actionType?.trim()) {
      where.AND.push({ actionType: filters.actionType.trim() });
    }

    if (filters?.search?.trim()) {
      const searchTerm = filters.search.trim();
      where.AND.push({
        OR: [
          { role: { contains: searchTerm, mode: "insensitive" } },
          { actionType: { contains: searchTerm, mode: "insensitive" } },
          { performedByName: { contains: searchTerm, mode: "insensitive" } },
          { performedByEmail: { contains: searchTerm, mode: "insensitive" } },
        ],
      });
    }

    const offset = (page - 1) * pageSize;

    const [auditEntries, total] = await Promise.all([
      prisma.indentAuditTrail.findMany({
        where,
        skip: offset,
        take: pageSize,
        orderBy: { timestamp: "desc" },
        select: {
          indentId: true,
          actionType: true,
          role: true,
          performedByName: true,
          performedByEmail: true,
          timestamp: true,
          modifications: true,
        },
      }),
      prisma.indentAuditTrail.count({ where }),
    ]);

    return {
      success: true,
      data: auditEntries,
      pagination: {
        total,
        page,
        pageSize,
        totalPages: Math.ceil(total / pageSize),
      },
    };
  } catch (error) {
    console.error("Failed to fetch audit trail", error);
    throw new Error("Unable to fetch audit trail");
  }
};


export const getObservationAuditTrail = async (
  user: User,
  observationId?: string,
  page: number = 1,
  pageSize: number = 10,
  filters?: {
    userRole?: string;      // acts as exact filter
    actionType?: string;    // acts as exact filter
    search?: string;        // acts as keyword search on userRole/actionType
  }
) => {
  try {
    if (
      user.role !== "COMPLIANCE_MAKER" &&
      user.role !== "COMPLIANCE_CHECKER"
    ) {
      throw new Error("You are not authorized to view audit trails.");
    }

    const where: any = { AND: [] };

    if (observationId) {
      where.AND.push({ observationId });
    }

    if (filters?.userRole?.trim()) {
      where.AND.push({ role: filters.userRole.trim() });
    }

    if (filters?.actionType?.trim()) {
      where.AND.push({ actionType: filters.actionType.trim() });
    }

    if (filters?.search?.trim()) {
      const searchTerm = filters.search.trim();
      where.AND.push({
        OR: [
          { role: { contains: searchTerm, mode: "insensitive" } },
          { actionType: { contains: searchTerm, mode: "insensitive" } },
          { performedByName: { contains: searchTerm, mode: "insensitive" } },
          { performedByEmail: { contains: searchTerm, mode: "insensitive" } },
        ],
      });
    }

    const offset = (page - 1) * pageSize;

    const [auditEntries, total] = await Promise.all([
      prisma.observationAuditTrail.findMany({
        where,
        skip: offset,
        take: pageSize,
        orderBy: { timestamp: "desc" },
        select: {
          observationId: true,
          actionType: true,
          role: true,
          performedByName: true,
          performedByEmail: true,
          timestamp: true,
          modifications: true,
        },
      }),
      prisma.observationAuditTrail.count({ where }),
    ]);

    return {
      success: true,
      data: auditEntries,
      pagination: {
        total,
        page,
        pageSize,
        totalPages: Math.ceil(total / pageSize),
      },
    };
  } catch (error) {
    console.error("Failed to fetch audit trail", error);
    throw new Error("Unable to fetch audit trail");
  }
};
