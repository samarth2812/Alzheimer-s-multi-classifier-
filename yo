import { Response as ExpressResponse } from "express";
import ExcelJS from "exceljs";
import { Stream } from "stream";
import { prisma } from "../prisma";
import { getStepName, getNameFromStep } from "../helpers/workflowHelper";
import { fetchUsersList } from "../helpers/fetchUsers";
import {
  DEPARTMENT_MAPPING,
  INDENT_CATEGORY_MAPPING,
  INDENT_PRIORITY_MAPPING,
} from "../constants/mappings";
import { Department, IndentCategory, IndentPriority, Position } from "@prisma/client";

export const generateIndentExcel = async (
  res: ExpressResponse,
  userRole: Position,
  userDepartment: Department,
  filters: {
    status?: "open" | "Closed";
    priorityLevel?: IndentPriority;
    department?: Department;
    category?: IndentCategory;
    search?: string;
    startDate?: string;
    endDate?: string;
  }
) => {
  try {
    const workbook = new ExcelJS.Workbook();
    workbook.creator = "Indent Management System";
    workbook.created = new Date();

    const worksheet = workbook.addWorksheet("Indents", {
      views: [{ state: "frozen", ySplit: 1 }],
    });

    const headers = [
      "Serial Number",
      "Description",
      "Priority",
      "Category",
      "Department",
      "Created By",
      "Assigned To",
      "Current Step",
      "Status",
      "Created At",
      "Updated At",
      "Closed Date",
      "Comments",
    ];

    const headerRow = worksheet.addRow(headers);
    headerRow.font = { bold: true, size: 11 };
    headerRow.fill = {
      type: "pattern",
      pattern: "solid",
      fgColor: { argb: "F0F0F0" },
    };

    const where: any = { AND: [{ isDeleted: false }] };

    if (
      (userRole === "DEPARTMENT_MAKER" || userRole === "DEPARTMENT_CHECKER") &&
      userDepartment
    ) {
      where.AND.push({ department: userDepartment });
    }

    if (filters.status === "Closed") {
      where.AND.push({ openStatus: false });
    } else {
      where.AND.push({ openStatus: true });
    }

    if (filters.priorityLevel) {
      where.AND.push({ priority: INDENT_PRIORITY_MAPPING[filters.priorityLevel] });
    }

    if (filters.department) {
      where.AND.push({ department: DEPARTMENT_MAPPING[filters.department] });
    }

    if (filters.category) {
      where.AND.push({ category: INDENT_CATEGORY_MAPPING[filters.category] });
    }

    if (filters.startDate) {
      where.AND.push({ createdAt: { gte: new Date(filters.startDate) } });
    }

    if (filters.endDate) {
      where.AND.push({ closedDate: { lte: new Date(filters.endDate) } });
    }

    if (filters.search?.trim()) {
      const searchTerm = filters.search.trim();
      where.AND.push({
        OR: [
          { description: { contains: searchTerm, mode: "insensitive" } },
          { comments: { contains: searchTerm, mode: "insensitive" } },
          { indentId: { contains: searchTerm, mode: "insensitive" } },
        ],
      });
    }

    const indents = await prisma.indents.findMany({
      where,
      orderBy: { updatedAt: "desc" },
    });

    const formatDate = (date: Date | null): string => {
      if (!date) return "N/A";
      return date.toLocaleDateString("en-GB");
    };

    for (let index = 0; index < indents.length; index++) {
      const indent = indents[index];
      const pendingWith = getNameFromStep(indent.currStep, indent.prevStep);
      const currentStepName = getStepName(indent.currStep, indent.prevStep, indent.department);
      let assigneeName = "N/A";

      if (pendingWith !== "Closed") {
        try {
          const response = await fetchUsersList({
            ...(pendingWith === "DEPARTMENT_MAKER" || pendingWith === "DEPARTMENT_CHECKER"
              ? { department: indent.department }
              : {}),
            role: pendingWith as Position,
          });

          const userList = response || [];

          if (pendingWith === "DEPARTMENT_MAKER") {
            const match = userList.find((user: any) => user.email === indent.assignedTo);
            if (match) assigneeName = match.name || match.email;
          } else if (userList.length) {
            assigneeName = userList.map((u: any) => u.name || u.email).join(", ");
          }
        } catch (err) {
          console.warn("Error fetching assignee list:", err);
        }
      }

      const row = [
        index + 1, // Serial Number
        indent.description || "N/A",
        indent.priority || "N/A",
        indent.category || "N/A",
        indent.department || "N/A",
        indent.createdBy || "N/A",
        assigneeName,
        currentStepName,
        indent.openStatus ? "Open" : "Closed",
        formatDate(indent.createdAt),
        formatDate(indent.updatedAt),
        formatDate(indent.closedDate),
        indent.comments || "N/A",
      ];

      worksheet.addRow(row);
    }

    worksheet.columns.forEach((column: any) => {
      if (column) column.width = 18;
    });

    await workbook.xlsx.write(res as unknown as Stream);
    return true;
  } catch (error: any) {
    console.error("Error in generateIndentExcel:", error);
    throw new Error(`Indent Excel export failed: ${error.message}`);
  }
};
