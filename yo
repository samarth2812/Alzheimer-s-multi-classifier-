import React from "react";
import { Box, TextField, Button, Typography, InputAdornment, Skeleton } from "@mui/material";
import { BsTable } from "react-icons/bs";

// Components
import IndentFormDialog from "./indentFormDialog";


// Styles
import { topBarStyle } from "layouts/resuableComponents/styles";
import { topBarSearchStyle } from "layouts/resuableComponents/styles";
import { animatedButtonStyle } from "layouts/resuableComponents/styles";
import { iconButtonStyle } from "layouts/resuableComponents/styles";
import { AttachmentDrawer } from "layouts/resuableComponents/attachmentDrawer";
import DescriptionDialog from "layouts/resuableComponents/customDescriptionViewDialog";
import CustomDeleteDialog from "layouts/resuableComponents/customDeleteDialog";
import { formatTableData } from "./tableFormatter";
import { useIndentManagement } from "./useIndentManagement";
import { Add, FilterAlt, Search } from "@mui/icons-material";
import DataTable from "examples/Tables/DataTable";
import EmptyStateBox from "layouts/resuableComponents/emptyStateBox";
import PaginationFooter from "layouts/resuableComponents/PaginationFooter";

const CreateIndentPage = () => {
  const {
    // State
    data,
    searchTerm,
    isModalOpen,
    setIsModalOpen,
    editIndentData,
    setEditIndentData,
    indentToDelete,
    setIndentToDelete,
    isDeleteDialogOpen,
    setIsDeleteDialogOpen,
    descriptionDialogOpen,
    setDescriptionDialogOpen,
    currentDescription,
    setCurrentDescription,
    loading,
    formData,
    viewAttachementDialogOpen,
    setViewAttachementDialogOpen,
    attachments,
    setAttachments,
    indentId,
    setIndentId,
    currentPage,
    rowsPerPage,
    totalRecords,
    totalPages,
    displayData,
    user,

    // Handlers
    handleSearch,
    handleAddIndentClick,
    handleChange,
    handleIndentDelete,
    handleSubmitIndent,
    handleSubmitRemark,
    handleEditRemark,
    handleSortByPriority,
    handlePageChange,
    handleRowsPerPageChange,
    fetchData,
    formatDateTime,
  } = useIndentManagement("created");

  const tableData = formatTableData(displayData, "created", {
    currentPage,
    rowsPerPage,
    user,
    formData,
    setCurrentDescription,
    setDescriptionDialogOpen,
    setEditIndentData,
    setIsModalOpen,
    setIndentToDelete,
    setIsDeleteDialogOpen,
    setIndentId,
    setAttachments,
    setViewAttachementDialogOpen,
    handleChange,
    handleSubmitRemark,
    handleEditRemark,
    handleSubmitIndent,
    formatDateTime,
  });

  return (
    <>
      <Box
        sx={{
          width: "100%",
          height: "100%",
          display: "flex",
          flexDirection: "column",
          gap: "8px",
          position: "relative",
        }}
      >
        <Box sx={{ ...topBarStyle, mb: 1, gap: 2 }}>
          <TextField
            fullWidth
            placeholder="Search Indent Records..."
            variant="outlined"
            sx={topBarSearchStyle}
            value={searchTerm}
            onChange={handleSearch}
            InputProps={{
              startAdornment: (
                <InputAdornment position="start">
                  <Search fontSize="medium" sx={iconButtonStyle} />
                </InputAdornment>
              ),
            }}
          />
          {tableData && tableData?.rows && tableData?.rows.length > 2 && (
            <>
              <Button
                size="small"
                color="info"
                sx={animatedButtonStyle}
                startIcon={<FilterAlt />}
                onClick={handleSortByPriority}
              >
                Priority
              </Button>
              <Typography
                variant="body2"
                sx={{
                  color: (theme) => theme.palette.custom.text1,
                  opacity: 0.5,
                }}
              >
                |
              </Typography>
            </>
          )}
          <Button
            size="small"
            startIcon={<Add />}
            onClick={handleAddIndentClick}
            color="info"
            sx={animatedButtonStyle}
          >
            Add Indent
          </Button>
        </Box>

        {loading ? (
          <Box>
            {[...Array(5)].map((_, index) => (
              <Skeleton
                key={index}
                variant="rectangular"
                animation="wave"
                height={40}
                sx={{
                  mb: 2,
                  borderRadius: 2,
                  backgroundColor: (theme) => theme.palette.custom.background1,
                }}
              />
            ))}
          </Box>
        ) : tableData && tableData?.rows && tableData?.rows.length > 0 ? (
          <Box pb={1} sx={{ overflowY: "auto", display: "flex", maxWidth: "100%" }}>
            <DataTable
              table={tableData}
              isSorted={false}
              entriesPerPage={true}
              showTotalEntries={true}
              noEndBorder
            />
          </Box>
        ) : (
          <EmptyStateBox
            icon={BsTable}
            title="Currently there are no created Indents"
            description="Start a new indent by tapping the 'Add Indent' button "
          />
        )}

        {tableData && tableData?.rows && tableData?.rows.length > 0 && (
          <PaginationFooter
            currentPage={currentPage}
            rowsPerPage={rowsPerPage}
            totalPages={totalPages}
            totalRecords={totalRecords}
            onPageChange={handlePageChange}
            onRowsPerPageChange={handleRowsPerPageChange}
            loading={loading}
          />
        )}
      </Box>

      <IndentFormDialog
        open={isModalOpen}
        onClose={() => setIsModalOpen(false)}
        initialData={editIndentData}
        onSubmit={fetchData}
      />

      <CustomDeleteDialog
        open={isDeleteDialogOpen}
        onClose={() => setIsDeleteDialogOpen(false)}
        onConfirm={handleIndentDelete}
        type="Indent"
        field={indentToDelete ? indentToDelete.department : ""}
      />
      <DescriptionDialog
        open={descriptionDialogOpen}
        onClose={() => setDescriptionDialogOpen(false)}
        description={currentDescription}
      />
      <AttachmentDrawer
        moduleId={indentId}
        module={"INDENT"}
        uploadedBy={user.email}
        uploadedByRole={user.role}
        attachments={attachments}
        open={viewAttachementDialogOpen}
        onClose={() => setViewAttachementDialogOpen(false)}
        onUploadComplete={fetchData}
        user={user}
      />
    </>
  );
};

export default CreateIndentPage;




import { useEffect, useState, useMemo, useCallback } from "react";
import toast from "react-hot-toast";
import { useSelector, useDispatch } from "react-redux";
import debounce from "lodash.debounce";
import { apiRequest } from "../../axios/apiRequest";
import { fetchNotifications } from "features/notificationSlice";

export const useIndentManagement = (pageType) => {
  // Common state
  const [data, setData] = useState([]);
  const [searchTerm, setSearchTerm] = useState("");
  const [filteredData, setFilteredData] = useState([]);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editIndentData, setEditIndentData] = useState(null);
  const [indentToDelete, setIndentToDelete] = useState(null);
  const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false);
  const [descriptionDialogOpen, setDescriptionDialogOpen] = useState(false);
  const [currentDescription, setCurrentDescription] = useState("");
  const [loading, setLoading] = useState(true);
  const [formData, setFormData] = useState({});
  const [viewAttachementDialogOpen, setViewAttachementDialogOpen] = useState(false);
  const [attachments, setAttachments] = useState([]);
  const [indentId, setIndentId] = useState("");

  // Pagination state
  const [currentPage, setCurrentPage] = useState(1);
  const [rowsPerPage, setRowsPerPage] = useState(5);
  const [totalRecords, setTotalRecords] = useState(1);
  const [totalPages, setTotalPages] = useState(1);

  const user = useSelector((state) => state.user.user);
  const dispatch = useDispatch();

  // API endpoint configuration based on page type
  const getApiEndpoint = useCallback(() => {
    const baseUrl = window._env_?.REACT_APP_BACKEND_URL || process.env.REACT_APP_BACKEND_URL;
    const role = user?.role;
    const department = user?.department;
    const pagination = `page=${currentPage}&limit=${rowsPerPage}`;

    switch (pageType) {
      case "created":
        return `${baseUrl}/api/v1/indents/${role}/created?${pagination}`;
      case "latest":
        return role === "COMPLIANCE_CHECKER"
          ? `${baseUrl}/api/v1/indents/${role}/latest?${pagination}`
          : `${baseUrl}/api/v1/indents/${role}/latest/${department}?${pagination}`;
      case "closure":
        return `${window._env_?.REACT_APP_BACKEND_URL || process.env.REACT_APP_BACKEND_URL}/api/v1/indents/${role}/closure?${pagination}`;
      case "rejected":
        role === "COMPLIANCE_MAKER"
          ? `${window._env_?.REACT_APP_BACKEND_URL || process.env.REACT_APP_BACKEND_URL}/api/v1/indents/${role}/rejected?${pagination}`
          : `${window._env_?.REACT_APP_BACKEND_URL || process.env.REACT_APP_BACKEND_URL}/api/v1/indents/${user}/rejected/${department}?${pagination}`;
      default:
        return `${baseUrl}/api/v1/indents/${role}/created?${pagination}`;
    }
  }, [pageType, user?.role, user?.department, currentPage, rowsPerPage]);

  // Fetch data function
  const fetchData = useCallback(async () => {
    if (!user?.role) return;

    setLoading(true);
    try {
      const endpoint = getApiEndpoint();
      const response = await apiRequest("GET", endpoint);

      setData(response.data.data);
      setTotalRecords(response.data.pagination.total);
      setTotalPages(response.data.pagination.totalPages);

      // Update attachments if indentId exists
      if (indentId) {
        const updatedIndent = response.data.data.find((indent) => indent.indentId === indentId);
        if (updatedIndent) {
          setAttachments(updatedIndent.attachments || []);
        }
      }
    } catch (error) {
      toast.error("Failed to fetch Indent");
    } finally {
      setLoading(false);
    }
  }, [getApiEndpoint, indentId, user?.role]);

  // Initial data fetch
  useEffect(() => {
    fetchData();
  }, [fetchData]);

  // Debounced search function
  const debouncedFilter = useMemo(
    () =>
      debounce((term, data) => {
        if (term) {
          const lowercasedFilter = term.toLowerCase();
          const filtered = data.filter((item) =>
            Object.keys(item).some((key) => {
              const value = item[key];
              return value !== null && value.toString().toLowerCase().includes(lowercasedFilter);
            })
          );
          setFilteredData(filtered);
        } else {
          setFilteredData(data);
        }
      }, 300),
    []
  );

  // Search effect with normalization
  useEffect(() => {
    const normalizeSearchTerm = (term) => {
      const mappings = {
        "in progress": "in_progress",
        completed: "completed",
        pending: "pending",
        low: "low",
        medium: "medium",
        high: "high",
      };
      const lowerTerm = term.toLowerCase().trim();
      if (!lowerTerm) return "";
      if (mappings[lowerTerm]) {
        return mappings[lowerTerm];
      }
      for (const [key, value] of Object.entries(mappings)) {
        if (key.startsWith(lowerTerm) || lowerTerm.includes(key)) {
          return value;
        }
      }
      return lowerTerm;
    };

    const normalizedTerm = normalizeSearchTerm(searchTerm);

    if (!normalizedTerm) {
      setFilteredData(data);
    } else {
      debouncedFilter(normalizedTerm, data);
    }

    return () => debouncedFilter.cancel();
  }, [searchTerm, data, debouncedFilter]);

  // Common handlers
  const handleSearch = useCallback((event) => {
    setSearchTerm(event.target.value);
  }, []);

  const handleAddIndentClick = useCallback(() => {
    setEditIndentData(null);
    setIsModalOpen(true);
  }, []);

  const handleChange = useCallback((e, indentId) => {
    const { name, value } = e.target;
    setFormData((prev) => ({
      ...prev,
      [indentId]: {
        ...prev[indentId],
        [name]: value,
      },
    }));
  }, []);

  const handleIndentDelete = useCallback(async () => {
    if (!indentToDelete) return;

    try {
      const deleteIndentUrl = `${window._env_?.REACT_APP_BACKEND_URL || process.env.REACT_APP_BACKEND_URL}/api/v1/indents/${indentToDelete.indentId}`;
      const result = await apiRequest("DELETE", deleteIndentUrl);

      if (result.status === 200 || result.status === 204) {
        toast.success("Indent Deleted Successfully");
        setData((prev) => prev.filter((indent) => indent.indentId !== indentToDelete.indentId));
        fetchData();
      }
    } catch (error) {
      console.error("Error deleting indent:", error);
    } finally {
      setIsDeleteDialogOpen(false);
    }
  }, [indentToDelete, fetchData]);

  const handleSubmitIndent = useCallback(
    async (indentId, department) => {
      try {
        const isComplianceDepartment = department === "COMPLIANCE";
        const payload = {
          updatedFields: {
            type: "WORKFLOW_UPDATE",
            rejectedStatus:
              pageType === "latest" || pageType === "rejected" || pageType === "closure"
                ? formData[indentId]?.approvalStatus === "approve"
                  ? false
                  : true
                : false,
          },
        };

        const result = await apiRequest(
          "PUT",
          `${window._env_?.REACT_APP_BACKEND_URL || process.env.REACT_APP_BACKEND_URL}/api/v1/indents/${user.role}/${department}/${indentId}`,
          payload
        );

        if (result.status === 200 || result.status === 204) {
          // Success message logic based on page type and approval status
          if (pageType === "created") {
            toast.success("Indent Sent to Compliance Checker Successfully");
          } else if (pageType === "latest") {
            const approvalStatus = formData[indentId]?.approvalStatus;
            // Add specific success messages based on role and approval status
            if (isComplianceDepartment) {
              if (approvalStatus === "approve") {
                toast.success("Indent Sent to back to Compliance Maker for Closure Successfully");
              } else {
                toast.success("Indent Sent to back to Compliance Maker Successfully");
              }
            } else {
              if (approvalStatus === "approve") {
                if (user.role === "COMPLIANCE_CHECKER") {
                  toast.success("Indent Sent to Department Maker Successfully");
                } else if (user.role === "DEPARTMENT_MAKER") {
                  toast.success("Indent Sent to Department Checker Successfully");
                } else {
                  toast.success("Indent Sent to Compliance Maker Successfully");
                }
              } else {
                if (user.role === "COMPLIANCE_CHECKER") {
                  toast.success("Indent Sent to back to Compliance Maker Successfully");
                } else if (user.role === "DEPARTMENT_MAKER") {
                  toast.success("Indent Sent to back to Compliance Maker Successfully");
                } else {
                  toast.success("Indent Sent to back to Department Maker Successfully");
                }
              }
            }
          } else if (pageType === "rejected") {
            if (formData[indentId]?.approvalStatus === "approve") {
              if (user.role === "COMPLIANCE_MAKER") {
                toast.success("Indent Sent to Compliance Checker Successfully");
              } else if (user.role === "DEPARTMENT_MAKER") {
                toast.success("Indent Sent to Department Checker Successfully");
              } else {
                toast.success("Indent Sent Successfully");
              }
            } else {
              if (user.role === "COMPLIANCE_MAKER") {
                toast.success("Indent Sent to back to Department Maker Successfully");
              } else if (user.role === "DEPARTMENT_MAKER") {
                toast.success("Indent Sent to back to Compliance Maker Successfully");
              } else {
                toast.success("Indent Sent Successfully");
              }
            }
          } else if (pageType === "closure") {
            if (formData[indentId]?.approvalStatus === "approve") {
              if (user.role === "COMPLIANCE_MAKER") {
                toast.success("Indent Sent For Closure to Compliance Checker Successfully");
              } else if (user.role === "COMPLIANCE_CHECKER") {
                toast.success("Indent Closed Successfully");
              }
            } else if (formData[indentId]?.approvalStatus !== "approve") {
              if (user.role === "COMPLIANCE_MAKER") {
                toast.success("Indent Sent Back to Department Maker Successfully");
              } else if (user.role === "COMPLIANCE_CHECKER") {
                toast.success("Indent Sent Back to Compliance Maker Successfully");
              }
            } else {
              toast.success("Indent Sent to back to Compliance Checker Successfully");
            }
          }
        }

        fetchData();
        dispatch(fetchNotifications());
      } catch (error) {
        toast.error("An error occurred while submitting the Indent.");
      }
    },
    [pageType, formData, user.role, fetchData, dispatch]
  );

  const handleSubmitRemark = useCallback(
    async (indentId, remarkData) => {
      try {
        const result = await apiRequest(
          "POST",
          `${window._env_?.REACT_APP_BACKEND_URL || process.env.REACT_APP_BACKEND_URL}/api/v1/indents/remarks/${indentId}`,
          remarkData
        );

        if (result.status === 201 || result.status === 204) {
          toast.success("Indent Remark Added Successfully");
        }
        fetchData();
      } catch (error) {
        toast.error("An error occurred while submitting the Remark.");
      }
    },
    [fetchData]
  );

  const handleEditRemark = useCallback(
    async (remarkId, remarkContent) => {
      try {
        const result = await apiRequest(
          "PUT",
          `${window._env_?.REACT_APP_BACKEND_URL || process.env.REACT_APP_BACKEND_URL}/api/v1/indents/remarks/${remarkId}`,
          { remarkContent }
        );

        if (result.status === 201 || result.status === 204) {
          toast.success("Indent Remark Updated Successfully");
        }
        fetchData();
      } catch (error) {
        toast.error("An error occurred while submitting the Remark.");
      }
    },
    [fetchData]
  );

  const handleSortByPriority = useCallback(() => {
    const priorityOrder = { HIGH: 3, MEDIUM: 2, LOW: 1 };
    const sortedData = [...data].sort((a, b) => {
      return priorityOrder[b.priority] - priorityOrder[a.priority];
    });
    setData(sortedData);
  }, [data]);

  const handlePageChange = useCallback((event, newPage) => {
    setCurrentPage(newPage);
  }, []);

  const handleRowsPerPageChange = useCallback((event) => {
    const { numericValue, resetToFirstPage } = event;
    setRowsPerPage(numericValue);
    if (resetToFirstPage) {
      setCurrentPage(1);
    }
  }, []);

  // Utility functions
  const formatDateTime = useCallback((dateString) => {
    return new Date(dateString).toLocaleString("en-GB", {
      day: "2-digit",
      month: "2-digit",
      year: "numeric",
      hour: "2-digit",
      minute: "2-digit",
      hour12: true,
    });
  }, []);

  const displayData = searchTerm ? filteredData : data;

  return {
    // State
    data,
    searchTerm,
    filteredData,
    isModalOpen,
    setIsModalOpen,
    editIndentData,
    setEditIndentData,
    indentToDelete,
    setIndentToDelete,
    isDeleteDialogOpen,
    setIsDeleteDialogOpen,
    descriptionDialogOpen,
    setDescriptionDialogOpen,
    currentDescription,
    setCurrentDescription,
    loading,
    formData,
    setFormData,
    viewAttachementDialogOpen,
    setViewAttachementDialogOpen,
    attachments,
    setAttachments,
    indentId,
    setIndentId,
    currentPage,
    rowsPerPage,
    totalRecords,
    totalPages,
    displayData,
    user,

    // Handlers
    handleSearch,
    handleAddIndentClick,
    handleChange,
    handleIndentDelete,
    handleSubmitIndent,
    handleSubmitRemark,
    handleEditRemark,
    handleSortByPriority,
    handlePageChange,
    handleRowsPerPageChange,
    fetchData,
    formatDateTime,
  };
};

