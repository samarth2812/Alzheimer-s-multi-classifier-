import { useEffect, useState, useMemo, useCallback, useRef } from "react";
import toast from "react-hot-toast";
import { useSelector, useDispatch } from "react-redux";
import debounce from "lodash.debounce";
import { apiRequest } from "../../axios/apiRequest";
import { fetchNotifications } from "features/notificationSlice";

export const useIndentManagement = (pageType) => {
  // Common state
  const [data, setData] = useState([]);
  const [searchTerm, setSearchTerm] = useState("");
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editIndentData, setEditIndentData] = useState(null);
  const [indentToDelete, setIndentToDelete] = useState(null);
  const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false);
  const [descriptionDialogOpen, setDescriptionDialogOpen] = useState(false);
  const [currentDescription, setCurrentDescription] = useState("");
  const [loading, setLoading] = useState(true);
  const [formData, setFormData] = useState({});
  const [viewAttachementDialogOpen, setViewAttachementDialogOpen] = useState(false);
  const [attachments, setAttachments] = useState([]);
  const [indentId, setIndentId] = useState("");

  // Pagination state
  const [currentPage, setCurrentPage] = useState(1);
  const [rowsPerPage, setRowsPerPage] = useState(5);
  const [totalRecords, setTotalRecords] = useState(1);
  const [totalPages, setTotalPages] = useState(1);

  const user = useSelector((state) => state.user.user);
  const dispatch = useDispatch();

  // API endpoint configuration based on page type
  const getApiEndpoint = useCallback(
    (searchQuery = "", page = currentPage, limit = rowsPerPage) => {
      const baseUrl = window._env_?.REACT_APP_BACKEND_URL || process.env.REACT_APP_BACKEND_URL;
      const role = user?.role;
      const department = user?.department;
      const pagination = `page=${page}&limit=${limit}`;
      const searchParam = searchQuery;

      switch (pageType) {
        case "created":
          return `${baseUrl}/api/v1/indents/${role}/created/${searchParam}?${pagination}`;
        case "latest":
          return role === "COMPLIANCE_CHECKER"
            ? `${baseUrl}/api/v1/indents/${role}/latest/${searchParam}?${pagination}`
            : `${baseUrl}/api/v1/indents/${role}/latest/${searchParam}/${department}?${pagination}`;
        case "closure":
          return `${baseUrl}/api/v1/indents/${role}/closure/${searchParam}?${pagination}`;
        case "rejected":
          return role === "COMPLIANCE_MAKER"
            ? `${baseUrl}/api/v1/indents/${role}/rejected/${searchParam}?${pagination}`
            : `${baseUrl}/api/v1/indents/${role}/rejected/${department}/${searchParam}?${pagination}`;
        default:
          return `${baseUrl}/api/v1/indents/${role}/created/${searchParam}?${pagination}`;
      }
    },
    [pageType, user?.role, user?.department]
  );

  // Main fetch function that accepts all parameters
  const fetchDataWithParams = useCallback(
    async (searchQuery = "", page = 1, limit = 5) => {
      if (!user?.role) return;

      setLoading(true);
      try {
        const endpoint = getApiEndpoint(searchQuery, page, limit);
        const response = await apiRequest("GET", endpoint);

        setData(response.data.data);
        setTotalRecords(response.data.pagination.total);
        setTotalPages(response.data.pagination.totalPages);

        // Update attachments if indentId exists
        if (indentId) {
          const updatedIndent = response.data.data.find((indent) => indent.indentId === indentId);
          if (updatedIndent) {
            setAttachments(updatedIndent.attachments || []);
          }
        }
      } catch (error) {
        toast.error("Failed to fetch Indent");
      } finally {
        setLoading(false);
      }
    },
    [getApiEndpoint, indentId, user?.role]
  );

  // Fetch data function using current state
  const fetchData = useCallback(
    async (searchQuery = "") => {
      await fetchDataWithParams(searchQuery, currentPage, rowsPerPage);
    },
    [fetchDataWithParams, currentPage, rowsPerPage]
  );

  // Separate function for fetching with search
  const fetchDataWithSearch = useCallback(
    async (searchQuery = "") => {
      await fetchDataWithParams(searchQuery, currentPage, rowsPerPage);
    },
    [fetchDataWithParams, currentPage, rowsPerPage]
  );

  // Debounced search function for backend API calls
  const debouncedSearch = useMemo(
    () =>
      debounce(async (searchQuery) => {
        setCurrentPage(1);
        await fetchDataWithParams(searchQuery, 1, rowsPerPage);
      }, 500),
    [fetchDataWithParams, rowsPerPage]
  );

  // Effect for initial load only
  useEffect(() => {
    if (!user?.role) return;

    const trimmedSearchTerm = searchTerm.trim();
    fetchDataWithParams(trimmedSearchTerm, currentPage, rowsPerPage);
  }, [user?.role]); // Only depend on user role for initial load

  // Effect for search term changes only
  useEffect(() => {
    if (!user?.role) return;

    const trimmedSearchTerm = searchTerm.trim();

    if (trimmedSearchTerm) {
      debouncedSearch(trimmedSearchTerm);
    } else {
      debouncedSearch.cancel();
      setCurrentPage(1);
      fetchDataWithParams("", 1, rowsPerPage);
    }

    return () => debouncedSearch.cancel();
  }, [searchTerm, user?.role, rowsPerPage, fetchDataWithParams]);

  // Common handlers
  const handleSearch = useCallback((event) => {
    setSearchTerm(event.target.value);
  }, []);

  const handleAddIndentClick = useCallback(() => {
    setEditIndentData(null);
    setIsModalOpen(true);
  }, []);

  const handleChange = useCallback((e, indentId) => {
    const { name, value } = e.target;
    setFormData((prev) => ({
      ...prev,
      [indentId]: {
        ...prev[indentId],
        [name]: value,
      },
    }));
  }, []);

  const handleIndentDelete = useCallback(async () => {
    if (!indentToDelete) return;

    try {
      const deleteIndentUrl = `${
        window._env_?.REACT_APP_BACKEND_URL || process.env.REACT_APP_BACKEND_URL
      }/api/v1/indents/${indentToDelete.indentId}`;
      const result = await apiRequest("DELETE", deleteIndentUrl);

      if (result.status === 200 || result.status === 204) {
        toast.success("Indent Deleted Successfully");
        // Refetch data after deletion
        const trimmedSearchTerm = searchTerm.trim();
        await fetchDataWithParams(trimmedSearchTerm, currentPage, rowsPerPage);
      }
    } catch (error) {
      console.error("Error deleting indent:", error);
    } finally {
      setIsDeleteDialogOpen(false);
    }
  }, [indentToDelete, fetchDataWithParams, searchTerm, currentPage, rowsPerPage]);

  const handleSubmitIndent = useCallback(
    async (indentId, department) => {
      try {
        const isComplianceDepartment = department === "COMPLIANCE";
        const payload = {
          updatedFields: {
            type: "WORKFLOW_UPDATE",
            rejectedStatus:
              pageType === "latest" || pageType === "rejected" || pageType === "closure"
                ? formData[indentId]?.approvalStatus === "approve"
                  ? false
                  : true
                : false,
          },
        };

        const result = await apiRequest(
          "PUT",
          `${
            window._env_?.REACT_APP_BACKEND_URL || process.env.REACT_APP_BACKEND_URL
          }/api/v1/indents/${user.role}/${department}/${indentId}`,
          payload
        );

        if (result.status === 200 || result.status === 204) {
          // Success message logic based on page type and approval status
          if (pageType === "created") {
            toast.success("Indent Sent to Compliance Checker Successfully");
          } else if (pageType === "latest") {
            const approvalStatus = formData[indentId]?.approvalStatus;
            // Add specific success messages based on role and approval status
            if (isComplianceDepartment) {
              if (approvalStatus === "approve") {
                toast.success("Indent Sent to back to Compliance Maker for Closure Successfully");
              } else {
                toast.success("Indent Sent to back to Compliance Maker Successfully");
              }
            } else {
              if (approvalStatus === "approve") {
                if (user.role === "COMPLIANCE_CHECKER") {
                  toast.success("Indent Sent to Department Maker Successfully");
                } else if (user.role === "DEPARTMENT_MAKER") {
                  toast.success("Indent Sent to Department Checker Successfully");
                } else {
                  toast.success("Indent Sent to Compliance Maker Successfully");
                }
              } else {
                if (user.role === "COMPLIANCE_CHECKER") {
                  toast.success("Indent Sent to back to Compliance Maker Successfully");
                } else if (user.role === "DEPARTMENT_MAKER") {
                  toast.success("Indent Sent to back to Compliance Maker Successfully");
                } else {
                  toast.success("Indent Sent to back to Department Maker Successfully");
                }
              }
            }
          } else if (pageType === "rejected") {
            if (formData[indentId]?.approvalStatus === "approve") {
              if (user.role === "COMPLIANCE_MAKER") {
                toast.success("Indent Sent to Compliance Checker Successfully");
              } else if (user.role === "DEPARTMENT_MAKER") {
                toast.success("Indent Sent to Department Checker Successfully");
              } else {
                toast.success("Indent Sent Successfully");
              }
            } else {
              if (user.role === "COMPLIANCE_MAKER") {
                toast.success("Indent Sent to back to Department Maker Successfully");
              } else if (user.role === "DEPARTMENT_MAKER") {
                toast.success("Indent Sent to back to Compliance Maker Successfully");
              } else {
                toast.success("Indent Sent Successfully");
              }
            }
          } else if (pageType === "closure") {
            if (formData[indentId]?.approvalStatus === "approve") {
              if (user.role === "COMPLIANCE_MAKER") {
                toast.success("Indent Sent For Closure to Compliance Checker Successfully");
              } else if (user.role === "COMPLIANCE_CHECKER") {
                toast.success("Indent Closed Successfully");
              }
            } else if (formData[indentId]?.approvalStatus !== "approve") {
              if (user.role === "COMPLIANCE_MAKER") {
                toast.success("Indent Sent Back to Department Maker Successfully");
              } else if (user.role === "COMPLIANCE_CHECKER") {
                toast.success("Indent Sent Back to Compliance Maker Successfully");
              }
            } else {
              toast.success("Indent Sent to back to Compliance Checker Successfully");
            }
          }
        }

        // Refetch data after submit
        const trimmedSearchTerm = searchTerm.trim();
        await fetchDataWithParams(trimmedSearchTerm, currentPage, rowsPerPage);
        dispatch(fetchNotifications());
      } catch (error) {
        toast.error("An error occurred while submitting the Indent.");
      }
    },
    [
      pageType,
      formData,
      user.role,
      fetchDataWithParams,
      dispatch,
      searchTerm,
      currentPage,
      rowsPerPage,
    ]
  );

  const handleSubmitRemark = useCallback(
    async (indentId, remarkData) => {
      try {
        const result = await apiRequest(
          "POST",
          `${
            window._env_?.REACT_APP_BACKEND_URL || process.env.REACT_APP_BACKEND_URL
          }/api/v1/indents/remarks/${indentId}`,
          remarkData
        );

        if (result.status === 201 || result.status === 204) {
          toast.success("Indent Remark Added Successfully");
        }
        // Refetch data after remark submission
        const trimmedSearchTerm = searchTerm.trim();
        await fetchDataWithParams(trimmedSearchTerm, currentPage, rowsPerPage);
      } catch (error) {
        toast.error("An error occurred while submitting the Remark.");
      }
    },
    [fetchDataWithParams, searchTerm, currentPage, rowsPerPage]
  );

  const handleEditRemark = useCallback(
    async (remarkId, remarkContent) => {
      try {
        const result = await apiRequest(
          "PUT",
          `${
            window._env_?.REACT_APP_BACKEND_URL || process.env.REACT_APP_BACKEND_URL
          }/api/v1/indents/remarks/${remarkId}`,
          { remarkContent }
        );

        if (result.status === 201 || result.status === 204) {
          toast.success("Indent Remark Updated Successfully");
        }
        // Refetch data after remark edit
        const trimmedSearchTerm = searchTerm.trim();
        await fetchDataWithParams(trimmedSearchTerm, currentPage, rowsPerPage);
      } catch (error) {
        toast.error("An error occurred while submitting the Remark.");
      }
    },
    [fetchDataWithParams, searchTerm, currentPage, rowsPerPage]
  );

  const handleSortByPriority = useCallback(() => {
    const priorityOrder = { HIGH: 3, MEDIUM: 2, LOW: 1 };
    const sortedData = [...data].sort((a, b) => {
      return priorityOrder[b.priority] - priorityOrder[a.priority];
    });
    setData(sortedData);
  }, [data]);

  const handlePageChange = useCallback(
    async (event, newPage) => {
      setCurrentPage(newPage);

      // Immediately fetch data for the new page
      const trimmedSearchTerm = searchTerm.trim();
      await fetchDataWithParams(trimmedSearchTerm, newPage, rowsPerPage);
    },
    [searchTerm, fetchDataWithParams, rowsPerPage]
  );

  const handleRowsPerPageChange = useCallback(
    async (event) => {
      const { numericValue, resetToFirstPage } = event;

      setRowsPerPage(numericValue);

      const newPage = resetToFirstPage ? 1 : currentPage;
      if (resetToFirstPage) {
        setCurrentPage(1);
      }

      // Immediately fetch data with new parameters
      const trimmedSearchTerm = searchTerm.trim();
      await fetchDataWithParams(trimmedSearchTerm, newPage, numericValue);
    },
    [currentPage, searchTerm, fetchDataWithParams]
  );

  // Utility functions
  const formatDateTime = useCallback((dateString) => {
    return new Date(dateString).toLocaleString("en-GB", {
      day: "2-digit",
      month: "2-digit",
      year: "numeric",
      hour: "2-digit",
      minute: "2-digit",
      hour12: true,
    });
  }, []);

  // Remove filteredData and displayData logic since search is now handled by backend
  const displayData = data;

  return {
    // State
    data,
    searchTerm,
    isModalOpen,
    setIsModalOpen,
    editIndentData,
    setEditIndentData,
    indentToDelete,
    setIndentToDelete,
    isDeleteDialogOpen,
    setIsDeleteDialogOpen,
    descriptionDialogOpen,
    setDescriptionDialogOpen,
    currentDescription,
    setCurrentDescription,
    loading,
    formData,
    setFormData,
    viewAttachementDialogOpen,
    setViewAttachementDialogOpen,
    attachments,
    setAttachments,
    indentId,
    setIndentId,
    currentPage,
    rowsPerPage,
    totalRecords,
    totalPages,
    displayData,
    user,

    // Handlers
    handleSearch,
    handleAddIndentClick,
    handleChange,
    handleIndentDelete,
    handleSubmitIndent,
    handleSubmitRemark,
    handleEditRemark,
    handleSortByPriority,
    handlePageChange,
    handleRowsPerPageChange,
    fetchData,
    fetchDataWithSearch,
    formatDateTime,
  };
};


import { useEffect, useState, useMemo, useCallback } from "react";
import toast from "react-hot-toast";
import { useSelector, useDispatch } from "react-redux";
import debounce from "lodash.debounce";
import { apiRequest } from "../../axios/apiRequest";
import { fetchNotifications } from "features/notificationSlice";

export const useObservationManagement = (pageType) => {
  // Common state
  const [data, setData] = useState([]);
  const [searchTerm, setSearchTerm] = useState("");
  const [filteredData, setFilteredData] = useState([]);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editObservationData, setEditObservationData] = useState(null);
  const [observationToDelete, setObservationToDelete] = useState(null);
  const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false);
  const [descriptionDialogOpen, setDescriptionDialogOpen] = useState(false);
  const [currentDescription, setCurrentDescription] = useState("");
  const [loading, setLoading] = useState(true);
  const [formData, setFormData] = useState({});
  const [viewAttachementDialogOpen, setViewAttachementDialogOpen] = useState(false);
  const [attachments, setAttachments] = useState([]);
  const [observationId, setObservationId] = useState("");

  // Pagination state
  const [currentPage, setCurrentPage] = useState(1);
  const [rowsPerPage, setRowsPerPage] = useState(5);
  const [totalRecords, setTotalRecords] = useState(1);
  const [totalPages, setTotalPages] = useState(1);

  const user = useSelector((state) => state.user.user);
  const dispatch = useDispatch();

  // API endpoint configuration based on page type
  const getApiEndpoint = useCallback(() => {
    const baseUrl = window._env_?.REACT_APP_BACKEND_URL || process.env.REACT_APP_BACKEND_URL;
    const role = user?.role;
    const department = user?.department;
    const pagination = `page=${currentPage}&limit=${rowsPerPage}`;

    switch (pageType) {
      case "created":
        return `${baseUrl}/api/v1/rbi-ise/${role}/created?${pagination}`;
      case "latest":
        return role === "COMPLIANCE_CHECKER"
          ? `${baseUrl}/api/v1/rbi-ise/${role}/latest?${pagination}`
          : `${baseUrl}/api/v1/rbi-ise/${role}/latest/${department}?${pagination}`;
      case "closure":
        return `${baseUrl}/api/v1/rbi-ise/${role}/closure?${pagination}`;
      case "rejected":
        return role === "COMPLIANCE_MAKER"
          ? `${baseUrl}/api/v1/rbi-ise/${role}/rejected?${pagination}`
          : `${baseUrl}/api/v1/rbi-ise/${role}/rejected/${department}?${pagination}`;
      default:
        return `${baseUrl}/api/v1/rbi-ise/${role}/created?${pagination}`;
    }
  }, [pageType, user?.role, user?.department, currentPage, rowsPerPage]);

  // Fetch data function
  const fetchData = useCallback(async () => {
    if (!user?.role) return;

    setLoading(true);
    try {
      const endpoint = getApiEndpoint();
      const response = await apiRequest("GET", endpoint);

      setData(response.data.data);
      setTotalRecords(response.data.pagination.total);
      setTotalPages(response.data.pagination.totalPages);

      // Update attachments if observationId exists
      if (observationId) {
        const updatedObservation = response.data.data.find(
          (observation) => observation.observationId === observationId
        );
        if (updatedObservation) {
          setAttachments(updatedObservation.attachments || []);
        }
      }
    } catch (error) {
      toast.error("Failed to fetch Observation");
    } finally {
      setLoading(false);
    }
  }, [getApiEndpoint, observationId, user?.role]);

  // Initial data fetch
  useEffect(() => {
    fetchData();
  }, [fetchData]);

  // Debounced search function
  const debouncedFilter = useMemo(
    () =>
      debounce((term, data) => {
        if (term) {
          const lowercasedFilter = term.toLowerCase();
          const filtered = data.filter((item) =>
            Object.keys(item).some((key) => {
              const value = item[key];
              return value !== null && value.toString().toLowerCase().includes(lowercasedFilter);
            })
          );
          setFilteredData(filtered);
        } else {
          setFilteredData(data);
        }
      }, 300),
    []
  );

  // Search effect with normalization
  useEffect(() => {
    const normalizeSearchTerm = (term) => {
      const mappings = {
        "in progress": "in_progress",
        completed: "completed",
        pending: "pending",
        "risk management": "risk_management",
        low: "low",
        medium: "medium",
        high: "high",
      };
      const lowerTerm = term.toLowerCase().trim();
      if (!lowerTerm) return "";
      if (mappings[lowerTerm]) {
        return mappings[lowerTerm];
      }
      for (const [key, value] of Object.entries(mappings)) {
        if (key.startsWith(lowerTerm) || lowerTerm.includes(key)) {
          return value;
        }
      }
      return lowerTerm;
    };

    const normalizedTerm = normalizeSearchTerm(searchTerm);

    if (!normalizedTerm) {
      setFilteredData(data);
    } else {
      debouncedFilter(normalizedTerm, data);
    }

    return () => debouncedFilter.cancel();
  }, [searchTerm, data, debouncedFilter]);

  // Common handlers
  const handleSearch = useCallback((event) => {
    setSearchTerm(event.target.value);
  }, []);

  const handleAddObservationClick = useCallback(() => {
    setEditObservationData(null);
    setIsModalOpen(true);
  }, []);

  const handleChange = useCallback((e, observationId) => {
    const { name, value } = e.target;
    setFormData((prev) => ({
      ...prev,
      [observationId]: {
        ...prev[observationId],
        [name]: value,
      },
    }));
  }, []);

  const handleObservationDelete = useCallback(async () => {
    if (!observationToDelete) return;

    try {
      const deleteObservationUrl = `${window._env_?.REACT_APP_BACKEND_URL || process.env.REACT_APP_BACKEND_URL}/api/v1/rbi-ise/${observationToDelete.observationId}`;
      const result = await apiRequest("DELETE", deleteObservationUrl);

      if (result.status === 200 || result.status === 204) {
        toast.success("Observation Deleted Successfully");
        setData((prev) => 
          prev.filter((observation) => observation.observationId !== observationToDelete.observationId)
        );
        fetchData();
      }
    } catch (error) {
      toast.error("Error deleting observation");
    } finally {
      setIsDeleteDialogOpen(false);
    }
  }, [observationToDelete, fetchData]);

  const handleSubmitObservation = useCallback(
    async (observationId, department) => {
      try {
        const isComplianceDepartment = department === "COMPLIANCE";
        const payload = {
          updatedFields: {
            updateType: "WORKFLOW_UPDATE",
            rejectedStatus:
              pageType === "latest" || pageType === "rejected" || pageType === "closure"
                ? formData[observationId]?.approvalStatus === "approve"
                  ? false
                  : true
                : false,
          },
        };

        const result = await apiRequest(
          "PUT",
          `${window._env_?.REACT_APP_BACKEND_URL || process.env.REACT_APP_BACKEND_URL}/api/v1/rbi-ise/${user.role}/${department}/${observationId}`,
          payload
        );

        if (result.status === 200 || result.status === 204) {
          // Success message logic based on page type and approval status
          if (pageType === "created") {
            toast.success("Observation Sent to Compliance Checker Successfully");
          } else if (pageType === "latest") {
            const approvalStatus = formData[observationId]?.approvalStatus;
            // Add specific success messages based on role and approval status
            if (isComplianceDepartment) {
              if (approvalStatus === "approve") {
                toast.success("Observation Sent to back to Compliance Maker for Closure Successfully");
              } else {
                toast.success("Observation Sent to back to Compliance Maker Successfully");
              }
            } else {
              if (approvalStatus === "approve") {
                if (user.role === "COMPLIANCE_CHECKER") {
                  toast.success("Observation Sent to Department Maker Successfully");
                } else if (user.role === "DEPARTMENT_MAKER") {
                  toast.success("Observation Sent to Department Checker Successfully");
                } else {
                  toast.success("Observation Sent to Compliance Maker Successfully");
                }
              } else {
                if (user.role === "COMPLIANCE_CHECKER") {
                  toast.success("Observation Sent to back to Compliance Maker Successfully");
                } else if (user.role === "DEPARTMENT_MAKER") {
                  toast.success("Observation Sent to back to Compliance Maker Successfully");
                } else {
                  toast.success("Observation Sent to back to Department Maker Successfully");
                }
              }
            }
          } else if (pageType === "rejected") {
            if (formData[observationId]?.approvalStatus === "approve") {
              if (user.role === "COMPLIANCE_MAKER") {
                toast.success("Observation Sent to Compliance Checker Successfully");
              } else if (user.role === "DEPARTMENT_MAKER") {
                toast.success("Observation Sent to Department Checker Successfully");
              } else {
                toast.success("Observation Sent Successfully");
              }
            } else {
              if (user.role === "COMPLIANCE_MAKER") {
                toast.success("Observation Sent to back to Department Maker Successfully");
              } else if (user.role === "DEPARTMENT_MAKER") {
                toast.success("Observation Sent to back to Compliance Maker Successfully");
              } else {
                toast.success("Observation Sent Successfully");
              }
            }
          } else if (pageType === "closure") {
            if (formData[observationId]?.approvalStatus === "approve") {
              if (user.role === "COMPLIANCE_MAKER") {
                toast.success("Observation Sent For Closure to Compliance Checker Successfully");
              } else if (user.role === "COMPLIANCE_CHECKER") {
                toast.success("Observation Closed Successfully");
              }
            } else if (formData[observationId]?.approvalStatus !== "approve") {
              if (user.role === "COMPLIANCE_MAKER") {
                toast.success("Observation Sent Back to Department Maker Successfully");
              } else if (user.role === "COMPLIANCE_CHECKER") {
                toast.success("Observation Sent Back to Compliance Maker Successfully");
              }
            } else {
              toast.success("Observation Sent to back to Compliance Checker Successfully");
            }
          }
        }

        fetchData();
        dispatch(fetchNotifications());
      } catch (error) {
        toast.error("An error occurred while submitting the Observation.");
      }
    },
    [pageType, formData, user.role, fetchData, dispatch]
  );

  const handleSubmitRemark = useCallback(
    async (observationId, remarkData) => {
      try {
        const result = await apiRequest(
          "POST",
          `${window._env_?.REACT_APP_BACKEND_URL || process.env.REACT_APP_BACKEND_URL}/api/v1/rbi-ise/remarks/${observationId}`,
          remarkData
        );

        if (result.status === 201 || result.status === 204) {
          toast.success("Observation Remark Added Successfully");
        }
        fetchData();
      } catch (error) {
        toast.error("An error occurred while submitting the Remark.");
      }
    },
    [fetchData]
  );

  const handleEditRemark = useCallback(
    async (observationId, remarkContent) => {
      try {
        const result = await apiRequest(
          "PUT",
          `${window._env_?.REACT_APP_BACKEND_URL || process.env.REACT_APP_BACKEND_URL}/api/v1/rbi-ise/remarks/${observationId}`,
          { remarkContent }
        );

        if (result.status === 201 || result.status === 204) {
          toast.success("Observation Remark Updated Successfully");
        }
        fetchData();
      } catch (error) {
        toast.error("An error occurred while submitting the Remark.");
      }
    },
    [fetchData]
  );

  const handleSortByStatus = useCallback(() => {
    const statusOrder = { PENDING: 1, IN_PROGRESS: 2, COMPLETED: 3 };
    const sortedData = [...data].sort((a, b) => {
      return statusOrder[a.status] - statusOrder[b.status];
    });
    setData(sortedData);
  }, [data]);

  const handlePageChange = useCallback((event, newPage) => {
    setCurrentPage(newPage);
  }, []);

  const handleRowsPerPageChange = useCallback((event) => {
    const { numericValue, resetToFirstPage } = event;
    setRowsPerPage(numericValue);
    if (resetToFirstPage) {
      setCurrentPage(1);
    }
  }, []);

  // Utility functions
  const formatDateTime = useCallback((dateString) => {
    return new Date(dateString).toLocaleString("en-GB", {
      day: "2-digit",
      month: "2-digit",
      year: "numeric",
      hour: "2-digit",
      minute: "2-digit",
      hour12: true,
    });
  }, []);

  const displayData = searchTerm ? filteredData : data;

  return {
    // State
    data,
    searchTerm,
    filteredData,
    isModalOpen,
    setIsModalOpen,
    editObservationData,
    setEditObservationData,
    observationToDelete,
    setObservationToDelete,
    isDeleteDialogOpen,
    setIsDeleteDialogOpen,
    descriptionDialogOpen,
    setDescriptionDialogOpen,
    currentDescription,
    setCurrentDescription,
    loading,
    formData,
    setFormData,
    viewAttachementDialogOpen,
    setViewAttachementDialogOpen,
    attachments,
    setAttachments,
    observationId,
    setObservationId,
    currentPage,
    rowsPerPage,
    totalRecords,
    totalPages,
    displayData,
    user,

    // Handlers
    handleSearch,
    handleAddObservationClick,
    handleChange,
    handleObservationDelete,
    handleSubmitObservation,
    handleSubmitRemark,
    handleEditRemark,
    handleSortByStatus,
    handlePageChange,
    handleRowsPerPageChange,
    fetchData,
    formatDateTime,
  };
};




import { useEffect, useState, useMemo, useCallback } from "react";
import toast from "react-hot-toast";
import { useSelector, useDispatch } from "react-redux";
import debounce from "lodash.debounce";
import { apiRequest } from "../../axios/apiRequest";
import { fetchNotifications } from "features/notificationSlice";

export const useIncidentManagement = (pageType) => {
  // Common state
  const [data, setData] = useState([]);
  const [searchTerm, setSearchTerm] = useState("");
  const [filteredData, setFilteredData] = useState([]);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editIncidentData, setEditIncidentData] = useState(null);
  const [incidentToDelete, setIncidentToDelete] = useState(null);
  const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false);
  const [descriptionDialogOpen, setDescriptionDialogOpen] = useState(false);
  const [currentDescription, setCurrentDescription] = useState("");
  const [loading, setLoading] = useState(true);
  const [formData, setFormData] = useState({});
  const [viewAttachementDialogOpen, setViewAttachementDialogOpen] = useState(false);
  const [attachments, setAttachments] = useState([]);
  const [incidentId, setIncidentId] = useState("");

  // Pagination state
  const [currentPage, setCurrentPage] = useState(1);
  const [rowsPerPage, setRowsPerPage] = useState(5);
  const [totalRecords, setTotalRecords] = useState(1);
  const [totalPages, setTotalPages] = useState(1);

  const user = useSelector((state) => state.user.user);
  const dispatch = useDispatch();

  // API endpoint configuration based on page type
  const getApiEndpoint = useCallback(() => {
    const baseUrl = window._env_?.REACT_APP_BACKEND_URL || process.env.REACT_APP_BACKEND_URL;
    const role = user?.role;
    const department = user?.department;
    const pagination = `page=${currentPage}&limit=${rowsPerPage}`;

    switch (pageType) {
      case "created":
        return `${baseUrl}/api/v1/incidents/${role}/created?${pagination}`;
      case "latest":
        return role === "COMPLIANCE_CHECKER"
          ? `${baseUrl}/api/v1/incidents/${role}/latest?${pagination}`
          : `${baseUrl}/api/v1/incidents/${role}/latest/${department}?${pagination}`;
      case "closure":
        return `${baseUrl}/api/v1/incidents/${role}/closure?${pagination}`;
      case "rejected":
        return role === "COMPLIANCE_MAKER"
          ? `${baseUrl}/api/v1/incidents/${role}/rejected?${pagination}`
          : `${baseUrl}/api/v1/incidents/${role}/rejected/${department}?${pagination}`;
      default:
        return `${baseUrl}/api/v1/incidents/${role}/created?${pagination}`;
    }
  }, [pageType, user?.role, user?.department, currentPage, rowsPerPage]);

  // Fetch data function
  const fetchData = useCallback(async () => {
    if (!user?.role) return;

    setLoading(true);
    try {
      const endpoint = getApiEndpoint();
      const response = await apiRequest("GET", endpoint);

      setData(response.data.data);
      setTotalRecords(response.data.pagination.total);
      setTotalPages(response.data.pagination.totalPages);

      // Update attachments if incidentId exists
      if (incidentId) {
        const updatedIncident = response.data.data.find(
          (incident) => incident.incidentId === incidentId
        );
        if (updatedIncident) {
          setAttachments(updatedIncident.attachments || []);
        }
      }
    } catch (error) {
      toast.error("Failed to fetch incidents");
    } finally {
      setLoading(false);
    }
  }, [getApiEndpoint, incidentId, user?.role]);

  // Initial data fetch
  useEffect(() => {
    fetchData();
  }, [fetchData]);

  // Debounced search function
  const debouncedFilter = useMemo(
    () =>
      debounce((term, data) => {
        if (term) {
          const lowercasedFilter = term.toLowerCase();
          const filtered = data.filter((item) =>
            Object.keys(item).some((key) => {
              const value = item[key];
              return value !== null && value.toString().toLowerCase().includes(lowercasedFilter);
            })
          );
          setFilteredData(filtered);
        } else {
          setFilteredData(data);
        }
      }, 300),
    []
  );

  // Search effect with normalization
  useEffect(() => {
    const normalizeSearchTerm = (term) => {
      const mappings = {
        "under review": "under_review",
        reported: "reported",
        resolved: "resolved",
        "show cause": "show_cause",
        penalty: "penalty",
        advisory: "advisory",
        low: "low",
        medium: "medium",
        high: "high",
        critical: "critical",
      };
      const lowerTerm = term.toLowerCase().trim();
      if (!lowerTerm) return "";
      if (mappings[lowerTerm]) {
        return mappings[lowerTerm];
      }
      for (const [key, value] of Object.entries(mappings)) {
        if (key.startsWith(lowerTerm) || lowerTerm.includes(key)) {
          return value;
        }
      }
      return lowerTerm;
    };

    const normalizedTerm = normalizeSearchTerm(searchTerm);

    if (!normalizedTerm) {
      setFilteredData(data);
    } else {
      debouncedFilter(normalizedTerm, data);
    }

    return () => debouncedFilter.cancel();
  }, [searchTerm, data, debouncedFilter]);

  // Common handlers
  const handleSearch = useCallback((event) => {
    setSearchTerm(event.target.value);
  }, []);

  const handleAddIncidentClick = useCallback(() => {
    setEditIncidentData(null);
    setIsModalOpen(true);
  }, []);

  const handleChange = useCallback((e, incidentId) => {
    const { name, value } = e.target;
    setFormData((prev) => ({
      ...prev,
      [incidentId]: {
        ...prev[incidentId],
        [name]: value,
      },
    }));
  }, []);

  const handleIncidentDelete = useCallback(async () => {
    if (!incidentToDelete) return;

    try {
      const deleteIncidentUrl = `${window._env_?.REACT_APP_BACKEND_URL || process.env.REACT_APP_BACKEND_URL}/api/v1/incidents/${incidentToDelete.incidentId}`;
      const result = await apiRequest("DELETE", deleteIncidentUrl);

      if (result.status === 200 || result.status === 204) {
        toast.success("Incident Deleted Successfully");
        setData((prev) => prev.filter((incident) => incident.incidentId !== incidentToDelete.incidentId));
        fetchData();
      }
    } catch (error) {
      console.error("Error deleting incident:", error);
    } finally {
      setIsDeleteDialogOpen(false);
    }
  }, [incidentToDelete, fetchData]);

  const handleSubmitIncident = useCallback(
    async (incidentId, department) => {
      try {
        const isComplianceDepartment = department === "COMPLIANCE";
        const payload = {
          updatedFields: {
            updateType: "WORKFLOW_UPDATE",
            rejectedStatus:
              pageType === "latest" || pageType === "rejected" || pageType === "closure"
                ? formData[incidentId]?.approvalStatus === "approve"
                  ? false
                  : true
                : false,
          },
        };

        const result = await apiRequest(
          "PUT",
          `${window._env_?.REACT_APP_BACKEND_URL || process.env.REACT_APP_BACKEND_URL}/api/v1/incidents/${user.role}/${department}/${incidentId}`,
          payload
        );

        if (result.status === 200 || result.status === 204) {
          // Success message logic based on page type and approval status
          if (pageType === "created") {
            toast.success("Incident Sent to Compliance Checker Successfully");
          } else if (pageType === "latest") {
            const approvalStatus = formData[incidentId]?.approvalStatus;
            // Add specific success messages based on role and approval status
            if (isComplianceDepartment) {
              if (approvalStatus === "approve") {
                toast.success("Incident Sent to back to Compliance Maker for Closure Successfully");
              } else {
                toast.success("Incident Sent to back to Compliance Maker Successfully");
              }
            } else {
              if (approvalStatus === "approve") {
                if (user.role === "COMPLIANCE_CHECKER") {
                  toast.success("Incident Sent to Department Maker Successfully");
                } else if (user.role === "DEPARTMENT_MAKER") {
                  toast.success("Incident Sent to Department Checker Successfully");
                } else {
                  toast.success("Incident Sent to Compliance Maker Successfully");
                }
              } else {
                if (user.role === "COMPLIANCE_CHECKER") {
                  toast.success("Incident Sent to back to Compliance Maker Successfully");
                } else if (user.role === "DEPARTMENT_MAKER") {
                  toast.success("Incident Sent to back to Compliance Maker Successfully");
                } else {
                  toast.success("Incident Sent to back to Department Maker Successfully");
                }
              }
            }
          } else if (pageType === "rejected") {
            if (formData[incidentId]?.approvalStatus === "approve") {
              if (user.role === "COMPLIANCE_MAKER") {
                toast.success("Incident Sent to Compliance Checker Successfully");
              } else if (user.role === "DEPARTMENT_MAKER") {
                toast.success("Incident Sent to Department Checker Successfully");
              } else {
                toast.success("Incident Sent Successfully");
              }
            } else {
              if (user.role === "COMPLIANCE_MAKER") {
                toast.success("Incident Sent to back to Department Maker Successfully");
              } else if (user.role === "DEPARTMENT_MAKER") {
                toast.success("Incident Sent to back to Compliance Maker Successfully");
              } else {
                toast.success("Incident Sent Successfully");
              }
            }
          } else if (pageType === "closure") {
            if (formData[incidentId]?.approvalStatus === "approve") {
              if (user.role === "COMPLIANCE_MAKER") {
                toast.success("Incident Sent For Closure to Compliance Checker Successfully");
              } else if (user.role === "COMPLIANCE_CHECKER") {
                toast.success("Incident Closed Successfully");
              }
            } else if (formData[incidentId]?.approvalStatus !== "approve") {
              if (user.role === "COMPLIANCE_MAKER") {
                toast.success("Incident Sent Back to Department Maker Successfully");
              } else if (user.role === "COMPLIANCE_CHECKER") {
                toast.success("Incident Sent Back to Compliance Maker Successfully");
              }
            } else {
              toast.success("Incident Sent to back to Compliance Checker Successfully");
            }
          }
        }

        fetchData();
        dispatch(fetchNotifications());
      } catch (error) {
        toast.error("An error occurred while submitting the Incident.");
      }
    },
    [pageType, formData, user.role, fetchData, dispatch]
  );

  const handleSubmitRemark = useCallback(
    async (incidentId, remarkData) => {
      try {
        const result = await apiRequest(
          "POST",
          `${window._env_?.REACT_APP_BACKEND_URL || process.env.REACT_APP_BACKEND_URL}/api/v1/incidents/remarks/${incidentId}`,
          remarkData
        );

        if (result.status === 201 || result.status === 204) {
          toast.success("Incident Remark Added Successfully");
        }
        fetchData();
      } catch (error) {
        toast.error("An error occurred while submitting the Remark.");
      }
    },
    [fetchData]
  );

  const handleEditRemark = useCallback(
    async (incidentId, remarkContent) => {
      try {
        const result = await apiRequest(
          "PUT",
          `${window._env_?.REACT_APP_BACKEND_URL || process.env.REACT_APP_BACKEND_URL}/api/v1/incidents/remarks/${incidentId}`,
          { remarkContent }
        );

        if (result.status === 201 || result.status === 204) {
          toast.success("Incident Remark Updated Successfully");
        }
        fetchData();
      } catch (error) {
        toast.error("An error occurred while submitting the Remark.");
      }
    },
    [fetchData]
  );

  const handleSortBySeverity = useCallback(() => {
    const severityOrder = { CRITICAL: 4, HIGH: 3, MEDIUM: 2, LOW: 1 };
    const sortedData = [...data].sort((a, b) => {
      return severityOrder[b.severity] - severityOrder[a.severity];
    });
    setData(sortedData);
  }, [data]);

  const handlePageChange = useCallback((event, newPage) => {
    setCurrentPage(newPage);
  }, []);

  const handleRowsPerPageChange = useCallback((event) => {
    const { numericValue, resetToFirstPage } = event;
    setRowsPerPage(numericValue);
    if (resetToFirstPage) {
      setCurrentPage(1);
    }
  }, []);

  // Utility functions
  const formatDateTime = useCallback((dateString) => {
    return new Date(dateString).toLocaleString("en-GB", {
      day: "2-digit",
      month: "2-digit",
      year: "numeric",
      hour: "2-digit",
      minute: "2-digit",
      hour12: true,
    });
  }, []);

  const displayData = searchTerm ? filteredData : data;

  return {
    // State
    data,
    searchTerm,
    filteredData,
    isModalOpen,
    setIsModalOpen,
    editIncidentData,
    setEditIncidentData,
    incidentToDelete,
    setIncidentToDelete,
    isDeleteDialogOpen,
    setIsDeleteDialogOpen,
    descriptionDialogOpen,
    setDescriptionDialogOpen,
    currentDescription,
    setCurrentDescription,
    loading,
    formData,
    setFormData,
    viewAttachementDialogOpen,
    setViewAttachementDialogOpen,
    attachments,
    setAttachments,
    incidentId,
    setIncidentId,
    currentPage,
    rowsPerPage,
    totalRecords,
    totalPages,
    displayData,
    user,

    // Handlers
    handleSearch,
    handleAddIncidentClick,
    handleChange,
    handleIncidentDelete,
    handleSubmitIncident,
    handleSubmitRemark,
    handleEditRemark,
    handleSortBySeverity,
    handlePageChange,
    handleRowsPerPageChange,
    fetchData,
    formatDateTime,
  };
};


