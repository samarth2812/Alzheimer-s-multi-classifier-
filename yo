   const fieldChanges = {
      department: { value: department },
      description: { value: description },
      status: { value: mappedStatus },
      priority: { value: priority },
      assignedTo: { value: assignedTo },
      comments: { value: comments },
      dueDate: { value: dueDate },
      ...(file && { file: { value: file } }),
      category: { value: category },
    };

    // âœ… Create audit trail entry
    await createIndentAuditTrail({
      indentId: newIndent.indentId,
      actionType: "CREATE",
      step: 0,
      role: user.role,
      performedByName: user.name,
      performedByEmail: user.email,
      fieldChanges,
    });


export const updateIndentById = async (
  indentId: string,
  role: StepRoles,
  department: string | undefined,
  user: User,
  updatedFields: {
    type: "FIELD_UPDATE" | "WORKFLOW_UPDATE";
    department?: Department;
    description?: string;
    status?: string;
    priority?: string;
    assignedTo?: string;
    dueDate?: string;
    comments?: string;
    openStatus?: boolean;
    rejectedStatus?: boolean;
  }
) => {
  try {
    if (!indentId || !role) {
      throw new Error("indentId & role are required");
    }

    if (role !== user.role) {
      throw new Error("You are not authorized to update indents for this role");
    }

    if (
      (role === "DEPARTMENT_CHECKER" || role === "DEPARTMENT_MAKER") &&
      department !== user.department
    ) {
      ("You are not authorized to update indents for this department");
    }

    const existingIndent = await prisma.indents.findUnique({
      where: { indentId },
    });

    if (!existingIndent) {
      throw new Error("Indent not found");
    }

    const { type, ...fieldsWithoutType } = updatedFields;
    const updateData: Record<string, any> = {};

    if (updatedFields.type === "WORKFLOW_UPDATE") {
      const rejectedStatus = updatedFields?.rejectedStatus ?? false;

      // Step update
      const { newCurrStep, newPrevStep } = stepBasedUpdateFilter(
        existingIndent.currStep,
        rejectedStatus,
        user.role,
        department
      );

      updateData.currStep = newCurrStep;
      updateData.prevStep = newPrevStep;
      updateData.rejectedStatus = rejectedStatus;

      // Determine status based on newCurrStep
      switch (newCurrStep) {
        case 0: // Compliance Maker
        case 1: // Compliance Checker
          updateData.status = "PENDING";
          break;
        case 2: // Department Maker
        case 3: // Department Checker
          updateData.status = "IN_PROGRESS";
          break;
      }

      // If final approval by Compliance Checker
      if (
        existingIndent.currStep === 4 &&
        user.role === "COMPLIANCE_CHECKER" &&
        !rejectedStatus
      ) {
        updateData.closedDate = new Date();
        updateData.status = "COMPLETED";
        updateData.openStatus = false;
      }
      updateData.lastStepChangeTime = new Date();
    }

    //  Process other user-updated fields
    for (const [key, value] of Object.entries(fieldsWithoutType)) {
      if (key === "department" && typeof value === "string") {
        updateData.department = DEPARTMENT_MAPPING[value] || value;
      } else if (key === "status" && typeof value === "string") {
        updateData.status = STATUS_MAPPING[value] || value;
      } else if (key === "priority" && typeof value === "string") {
        updateData.priority = INDENT_PRIORITY_MAPPING[value] || value;
      } else if (key === "category" && typeof value === "string") {
        updateData.priority = INDENT_CATEGORY_MAPPING[value] || value;
      } else if (key === "dueDate" && typeof value === "string") {
        updateData.dueDate = new Date(value);
      } else {
        updateData[key] = value;
      }
    }
    const updatedIndent = await prisma.indents.update({
      where: { indentId },
      data: updateData,
    });

    return updatedIndent;
  } catch (error) {
    console.error("Error updating indent:", error);
    throw new Error("Failed to update indent");
  }
};

export const deleteIndentById = async (indentId: string, user: User) => {
  try {
    if (user.role !== "COMPLIANCE_MAKER") {
      throw new Error("Unauthorized: Only Compliance Maker can delete indents");
    }
    const existingIndent = await prisma.indents.findUnique({
      where: { indentId },
    });

    if (!existingIndent) {
      throw new Error("indent not found");
    }

    await prisma.indents.update({
      where: { indentId },
      data: { isDeleted: true },
    });
  } catch (error) {
    console.error("Error deleting indent:", error);
    throw new Error("Failed to delete indent");
  }
};

