export const generateObligationsExcel = async (
  res: ExpressResponse,
  userRole: Position,
  userDepartment: Department,
  filters: {
    regulator?: string;
    status?: string;
    department?: Department;
    year?: string;
    compliance?: string;
    search?: string;
  }
) => {
  try {
    const workbook = new ExcelJS.Workbook();
    workbook.creator = "Obligation Management System";
    workbook.created = new Date();

    const worksheet = workbook.addWorksheet("Obligations", {
      views: [{ state: "frozen", ySplit: 1 }],
    });

    // Define headers
    const headers = [
      "ID",
      "Product",
      "Circular Reference",
      "Title",
      "Year",
      "Regulator",
      "Section Reference",
      "Applicability",
      "Regulatory Timeline",
      "Process",
      "Sub Process",
      "Department",
      "Responsible Owner",
      "Current Step",
      "Final Status",
      "Compliance",
      "Final Risk Score",
      "Test Step",
      "Test Evidence",
      "Created At",
      "Updated At",
    ];

    // Add header row
    const headerRow = worksheet.addRow(headers);
    headerRow.font = { bold: true, size: 11 };
    headerRow.fill = {
      type: "pattern",
      pattern: "solid",
      fgColor: { argb: "F0F0F0" },
    };

    // Build filter for data export (same logic as repository)
    const whereFilter: any = {
      AND: [{ isTempSaved: false }],
    };

    // Department-based pre-filtering
    if (userDepartment !== Department.COMPLIANCE) {
      whereFilter.AND.push({ department: userDepartment });
    }

    // Apply filters
    if (filters.status === "closed") {
      whereFilter.AND.push({ currStep: 6 });
    } else if (filters.status === "open") {
      whereFilter.AND.push({ currStep: { not: 6 } });
    }

    if (filters.regulator) {
      whereFilter.AND.push({
        regulator: {
          contains: filters.regulator,
          mode: "insensitive",
        },
      });
    }

    if (filters.department) {
      whereFilter.AND.push({ department: filters.department });
    }

    if (filters.year) {
      whereFilter.AND.push({ year: filters.year });
    }

    if (filters.compliance) {
      whereFilter.AND.push({
        compliance: convertToComplianceStatus(filters.compliance),
      });
    }

    // Search functionality
    if (filters.search && filters.search.trim()) {
      const searchTerm = filters.search.trim();
      whereFilter.AND.push({
        OR: [
          { title: { contains: searchTerm, mode: "insensitive" } },
          { circularReference: { contains: searchTerm, mode: "insensitive" } },
          { id: { contains: searchTerm, mode: "insensitive" } },
          { regulator: { contains: searchTerm, mode: "insensitive" } },
        ],
      });
    }

    // Fetch all matching obligations
    const obligations = await prisma.obligation.findMany({
      where: whereFilter,
      orderBy: { createdAt: "desc" },
    });

    // Helper function to format dates
    const formatDate = (date: Date | null): string => {
      if (!date) return "N/A";
      try {
        return date.toLocaleDateString("en-GB");
      } catch {
        return "N/A";
      }
    };

    // Add data rows
    obligations.forEach((obligation) => {
      const finalStatus = obligation.currStep === 6 ? "CLOSED" : "OPEN";

      const row = [
        obligation.id || "N/A",
        obligation.product || "N/A",
        obligation.circularReference || "N/A",
        obligation.title || "N/A",
        obligation.year || "N/A",
        obligation.regulator || "N/A",
        obligation.sectionReference || "N/A",
        obligation.applicability || "N/A",
        formatDate(obligation.regulatoryTimeline),
        obligation.process || "N/A",
        obligation.subProcess || "N/A",
        obligation.department || "N/A",
        obligation.responsibleOwner || "N/A",
        workflowHelper.getStepName(obligation.currStep),
        finalStatus,
        obligation.compliance || "N/A",
        obligation.finalRiskScore || "N/A",
        obligation.testStep || "N/A",
        obligation.testEvidence || "N/A",
        formatDate(obligation.createdAt),
        formatDate(obligation.updatedAt),
      ];

      worksheet.addRow(row);
    });

    // Set column widths
    worksheet.columns.forEach((column: any) => {
      if (column) column.width = 15;
    });

    // Write to response stream
    await workbook.xlsx.write(res as unknown as Stream);

    return true;
  } catch (error: any) {
    console.error("Error in generateObligationsExcel:", error);
    if (error instanceof ApiError) {
      throw error;
    }
    throw ApiError.internal(`Error generating Excel export: ${error.message}`);
  }
};
