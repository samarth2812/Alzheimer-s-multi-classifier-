/**
=========================================================
* Athena Guard - v2.2.0
=========================================================

* Product Page: https://www.creative-tim.com/product/material-dashboard-react
* Copyright 2023 Grant Thornton (https://www.creative-tim.com)

Coded by www.creative-tim.com

 =========================================================

* The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
*/

import { useEffect, useState, useMemo, useCallback } from "react";
import toast from "react-hot-toast";
import * as XLSX from "xlsx";
import { useSelector } from "react-redux";

// @mui material components
import DeleteIcon from "@mui/icons-material/Delete";
import DownloadIcon from "@mui/icons-material/Download";
import EditIcon from "@mui/icons-material/Edit";
import FilterAltIcon from "@mui/icons-material/FilterAlt";
import SearchIcon from "@mui/icons-material/Search";
import { IconButton, Tooltip, Typography } from "@mui/material";
import Box from "@mui/material/Box";
import InputAdornment from "@mui/material/InputAdornment";
import TextField from "@mui/material/TextField";
import Button from "@mui/material/Button";
import { ArrowCircleUp, ChatBubbleOutline, Visibility } from "@mui/icons-material";
import { apiRequest } from "../../axios/apiRequest";
import VisibilityIcon from "@mui/icons-material/Visibility";
import { Dialog, DialogContent, FormControl, Select, MenuItem } from "@mui/material";
import debounce from "lodash.debounce";

// Athena Guard components
import MDTypography from "components/MDTypography";
import DataTable from "examples/Tables/DataTable";
import { GiDatabase } from "react-icons/gi";
import Skeleton from "@mui/material/Skeleton";

// Athena Guard example components
import AddIcon from "@mui/icons-material/Add";
import { Stack } from "@mui/material";
import IndentFormDialog from "./indentFormDialog";
import CustomDeleteDialog from "layouts/resuableComponents/customDeleteDialog";
import DescriptionDialog from "layouts/resuableComponents/customDescriptionViewDialog";
import { topBarStyle } from "layouts/resuableComponents/styles";
import { topBarSearchStyle } from "layouts/resuableComponents/styles";
import { animatedButtonStyle } from "layouts/resuableComponents/styles";
import { iconButtonStyle } from "layouts/resuableComponents/styles";
import { z } from "zod";
import { CustomDropdownChip } from "layouts/resuableComponents/customDropdownChipField";
import RemarksInputDialog from "layouts/resuableComponents/RemarksInputDialog";
import CustomIconButton from "layouts/resuableComponents/CustomIconButton";
import EmptyStateBox from "layouts/resuableComponents/emptyStateBox";
import { BsTable } from "react-icons/bs";
import { AttachmentDrawer } from "layouts/resuableComponents/attachmentDrawer";
import InputWithDialog from "layouts/resuableComponents/InputWithDialog ";
import PaginationFooter from "layouts/resuableComponents/PaginationFooter";

const statusOptions = [
  { label: "Approve", value: "approve" },
  { label: "Reject", value: "reject" },
];

const CreateIndnetPage = () => {
  const [data, setData] = useState([]);
  const [searchTerm, setSearchTerm] = useState("");
  const [filteredData, setFilteredData] = useState([]);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editIndentData, setEditIndentData] = useState(null);
  const [indentToDelete, setIndentToDelete] = useState(null);
  const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false);
  const [page, setPage] = useState(0);
  const [descriptionDialogOpen, setDescriptionDialogOpen] = useState(false);
  const [currentDescription, setCurrentDescription] = useState("");
  const [loading, setLoading] = useState(true);
  const [formData, setFormData] = useState({});
  const [viewAttachementDialogOpen, setViewAttachementDialogOpen] = useState(false);
  const [attachments, setAttachments] = useState([]);
  const [indentId, setIndentId] = useState("");

  // Pagination state
  const [currentPage, setCurrentPage] = useState(1);
  const [rowsPerPage, setRowsPerPage] = useState(5);
  const [totalRecords, setTotalRecords] = useState(1);
  const [totalPages, setTotalPages] = useState(1);

  const user = useSelector((state) => state.user.user);
  const handleIndentDelete = async () => {
    try {
      const deleteIndentUrl = `${process.env.REACT_APP_BACKEND_URL}/api/v1/indents/${indentToDelete.indentId}`;
      const result = await apiRequest("DELETE", deleteIndentUrl);
      if (result.status === 200 || result.status === 204) {
        toast.success("Indent Deleted Successfully");
        setData((prev) => prev.filter((indent) => indent.indentId !== indentToDelete.indentId));
      }
    } catch (error) {
      console.error("Error deleting indent:", error);
    } finally {
      setIsDeleteDialogOpen(false);
    }
  };

  const fetchData = async () => {
    setLoading(true);
    try {
      const response = await apiRequest(
        "GET",
        `${process.env.REACT_APP_BACKEND_URL}/api/v1/indents/${user?.role}/created?page=${currentPage}&limit=${rowsPerPage}`
      );
      setData(response.data.data);
      setTotalRecords(response.data.pagination.total);
      setTotalPages(response.data.pagination.totalPages);

      if (indentId) {
        const updatedIndent = response.data.find((indent) => indent.indentId === indentId);
        if (updatedIndent) {
          setAttachments(updatedIndent.attachments || []);
        }
      }
    } catch (error) {
      toast.error("Failed to fetch Indent");
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchData();
  }, [totalPages, totalRecords]);

  // Debounced filter function
  const debouncedFilter = useMemo(
    () =>
      debounce((term, data) => {
        if (term) {
          const lowercasedFilter = term.toLowerCase();
          const filtered = data.filter((item) =>
            Object.keys(item).some((key) => {
              const value = item[key];
              return value !== null && value.toString().toLowerCase().includes(lowercasedFilter);
            })
          );
          setFilteredData(filtered);
        } else {
          setFilteredData(data);
        }
      }, 300),
    []
  );

  useEffect(() => {
    const normalizeSearchTerm = (term) => {
      const mappings = {
        "in progress": "in_progress",
        completed: "completed",
        pending: "pending",
        low: "low",
        medium: "medium",
        high: "high",
        // Add more mappings as needed
      };
      const lowerTerm = term.toLowerCase().trim();
      if (!lowerTerm) return ""; // Return empty string if nothing is typed
      // Exact match
      if (mappings[lowerTerm]) {
        return mappings[lowerTerm];
      }
      // Partial match
      for (const [key, value] of Object.entries(mappings)) {
        if (key.startsWith(lowerTerm) || lowerTerm.includes(key)) {
          return value;
        }
      }
      return lowerTerm;
    };
    const normalizedTerm = normalizeSearchTerm(searchTerm);

    if (!normalizedTerm) {
      // If search bar is empty, show all data
      setFilteredData(data);
    } else {
      debouncedFilter(normalizedTerm, data);
    }

    return () => debouncedFilter.cancel();
  }, [searchTerm, data]);

  const handleAddIndentClick = () => {
    setEditIndentData(null);
    setIsModalOpen(true);
  };

  const handleSearch = (event) => {
    setSearchTerm(event.target.value);
  };

  const handleSubmitIndent = async (indentId, department) => {
    try {
      const payload = {
        updatedFields: {
          type: "WORKFLOW_UPDATE",
          rejectedStatus: formData[indentId]?.approvalStatus === "approve" ? false : true,
        },
      };
      const result = await apiRequest(
        "PUT",
        `${process.env.REACT_APP_BACKEND_URL}/api/v1/indents/${user.role}/${department}/${indentId}`,
        payload
      );
      if (result.status === 200 || result.status === 204) {
        toast.success("Indent Sent to Compliace Checker Successfully");
      }
      fetchData();
    } catch (error) {
      toast.error("An error occurred while submitting the Indent.");
    }
  };

  const handleSubmitRemark = async (indentId, remarkData) => {
    try {
      const result = await apiRequest(
        "POST",
        `${process.env.REACT_APP_BACKEND_URL}/api/v1/indents/remarks/${indentId}`,
        remarkData
      );
      if (result.status === 201 || result.status === 204) {
        toast.success("Indent Remark Added Successfully");
      }
      fetchData();
    } catch (error) {
      toast.error("An error occurred while submitting the Remark.");
    }
  };

  const handleEditRemark = async (remarkId, remarkContent) => {
    try {
      const result = await apiRequest(
        "PUT",
        `${process.env.REACT_APP_BACKEND_URL}/api/v1/indents/remarks/${remarkId}`,
        { remarkContent }
      );
      if (result.status === 201 || result.status === 204) {
        toast.success("Indent Remark Updated Successfully");
      }
      fetchData();
    } catch (error) {
      toast.error("An error occurred while submitting the Remark.");
    }
  };

  const formatDateTime = (dateString) => {
    return new Date(dateString).toLocaleString("en-GB", {
      day: "2-digit",
      month: "2-digit",
      year: "numeric",
      hour: "2-digit",
      minute: "2-digit",
      hour12: true,
    });
  };

  // Function to sort by Priority
  const priorityOrder = { HIGH: 3, MEDIUM: 2, LOW: 1 };
  const sortByPriority = () => {
    const sorted = [...data].sort((a, b) => {
      return priorityOrder[b.priority] - priorityOrder[a.priority];
    });
    return sorted;
  };

  const handleSortByPriority = () => {
    const sortedData = sortByPriority(data);
    setData(sortedData);
  };
  const handleChange = (e, indentId) => {
    const { name, value } = e.target;

    setFormData((prev) => ({
      ...prev,
      [indentId]: {
        ...prev[indentId],
        [name]: value,
      },
    }));
  };

  // Function to format the table data for DataTable component
  const formatTableData = (rawData) => {
    const columns = [
      { Header: "S.No", accessor: "serialNumber", width: "5%", align: "center" },
      { Header: "Department", accessor: "department", width: "15%", align: "left" },
      { Header: "Description", accessor: "description", width: "15%", align: "left" },
      { Header: "Status", accessor: "status", width: "10%", align: "center" },
      { Header: "Priority", accessor: "priority", width: "15%", align: "left" },
      { Header: "Assigned To", accessor: "assignedTo", width: "10%", align: "center" },
      { Header: "Due Date", accessor: "dueDate", width: "10%", align: "center" },
      { Header: "Created At", accessor: "createdAt", width: "10%", align: "center" },
      { Header: "Comments", accessor: "comments", width: "15%", align: "left" },
      { Header: "Actions", accessor: "actions", width: "15%", align: "center" },
      { Header: "Attachments", accessor: "attachments", width: "15%", align: "center" },
      { Header: "Approval", accessor: "approval", width: "10%", align: "center" },
      { Header: "Remarks", accessor: "remarks", width: "15%", align: "center" },
      { Header: "Submit", accessor: "submit", width: "10%", align: "center" },
    ];

    const rows = rawData.map((item, index) => ({
      serialNumber: (
        <MDTypography
          variant="button"
          sx={{ color: (theme) => theme.palette.custom.text2, fontSize: "0.7rem !important" }}
        >
          {page * rowsPerPage + index + 1}
        </MDTypography>
      ),
      department: (
        <MDTypography
          variant="button"
          sx={{ color: (theme) => theme.palette.custom.text2, fontSize: "0.7rem !important" }}
        >
          {item.department.replace(/_/g, " ")}
        </MDTypography>
      ),
      description: (
        <Tooltip title="Preview Description">
          <IconButton
            sx={iconButtonStyle}
            onClick={() => {
              setCurrentDescription(item.description);
              setDescriptionDialogOpen(true);
            }}
          >
            <Visibility />
          </IconButton>
        </Tooltip>
      ),
      status: (
        <MDTypography
          variant="button"
          sx={{ color: (theme) => theme.palette.custom.text2, fontSize: "0.7rem !important" }}
        >
          {item.status.replace(/_/g, " ")}
        </MDTypography>
      ),
      priority: (
        <MDTypography
          variant="button"
          sx={{ color: (theme) => theme.palette.custom.text2, fontSize: "0.7rem !important" }}
        >
          {item.priority.replace(/_/g, " ")}
        </MDTypography>
      ),
      assignedTo: (
        <MDTypography
          variant="button"
          sx={{ color: (theme) => theme.palette.custom.text2, fontSize: "0.7rem !important" }}
        >
          {item.assignedTo}
        </MDTypography>
      ),
      dueDate: (
        <MDTypography
          variant="button"
          sx={{ color: (theme) => theme.palette.custom.text2, fontSize: "0.7rem !important" }}
        >
          {formatDateTime(item.dueDate)}
        </MDTypography>
      ),
      createdAt: (
        <MDTypography
          variant="button"
          sx={{ color: (theme) => theme.palette.custom.text2, fontSize: "0.7rem !important" }}
        >
          {formatDateTime(item.createdAt)}
        </MDTypography>
      ),
      comments: (
        <InputWithDialog
          value={item.comments}
          dialogTitle="Comments"
          dialogPlaceholder="Comments"
          cancelButtonLabel="Cancel"
          icon={VisibilityIcon}
          name="name"
          type="text"
          callOnSave={false}
          isDisabled={true}
        />
      ),
      actions: (
        <Stack direction="row" spacing={1} justifyContent="center">
          <Tooltip title="Edit Indent Details">
            <IconButton
              sx={iconButtonStyle}
              onClick={() => {
                setEditIndentData(item);
                setIsModalOpen(true);
              }}
            >
              <EditIcon />
            </IconButton>
          </Tooltip>
          <Tooltip title="Delete Indent">
            <IconButton
              sx={iconButtonStyle}
              onClick={() => {
                setIndentToDelete(item);
                setIsDeleteDialogOpen(true);
              }}
            >
              <DeleteIcon />
            </IconButton>
          </Tooltip>
        </Stack>
      ),
      attachments: (
        <>
          <Tooltip title="View Attachments">
            <span>
              <IconButton
                sx={iconButtonStyle}
                onClick={() => {
                  setIndentId(item.indentId);
                  setAttachments(item.attachments);
                  setViewAttachementDialogOpen(true);
                }}
              >
                <VisibilityIcon />
              </IconButton>
            </span>
          </Tooltip>
        </>
      ),
      approval: (
        <CustomDropdownChip
          options={statusOptions}
          value={formData[item.indentId]?.approvalStatus || ""}
          onChange={(e) => {
            handleChange(e, item.indentId);
          }}
          name="approvalStatus"
        />
      ),
      remarks: (
        <Box sx={{ minWidth: "150px" }}>
          <RemarksInputDialog
            name="remarks"
            value={formData[item.indentId]?.remarks || ""}
            onChange={(e) => handleChange(e, item.indentId)}
            remarks={item.remarkHistory || []}
            currentUser={user}
            onSendRemark={(newRemark) => handleSubmitRemark(item.indentId, newRemark)}
            onEditRemark={(remarkId, remarkText) => handleEditRemark(remarkId, remarkText)}
            icon={ChatBubbleOutline}
          />
        </Box>
      ),
      submit: (
        <CustomIconButton
          icon={ArrowCircleUp}
          label="Submit"
          disabled={(() => {
            const approvalStatus = formData[item.indentId]?.approvalStatus;
            const remarks = item.remarkHistory || [];

            const lastMyRemark = [...remarks].reverse().find((r) => r.role === user.role);

            const lastMyRemarkTime = lastMyRemark?.createdAt;

            const lastBackToMeTime = item.lastStepChangeTime;

            const addedNewRemark =
              lastMyRemarkTime && new Date(lastMyRemarkTime) > new Date(lastBackToMeTime);

            return !approvalStatus || !addedNewRemark;
          })()}
          onClick={() => handleSubmitIndent(item.indentId, item.department)}
        />
      ),
    }));

    return { columns, rows };
  };

  // Get paginated data
  const paginatedData = useMemo(() => {
    const startIndex = (currentPage - 1) * rowsPerPage;
    const endIndex = startIndex + rowsPerPage;
    if (data) {
      return data?.slice(startIndex, endIndex);
    } else {
      return [];
    }
  }, [data, currentPage, rowsPerPage]);

  // Handle page change
  const handlePageChange = useCallback((event, newPage) => {
    setCurrentPage(newPage);
  }, []);

  // Handle rows per page change
  const handleRowsPerPageChange = useCallback((event) => {
    const { numericValue, resetToFirstPage } = event;

    setRowsPerPage(numericValue);
    if (resetToFirstPage) {
      setCurrentPage(1); // Reset to first page when changing page size
    }
  }, []);
  const tableData = formatTableData(paginatedData);
  return (
    <>
      <Box
        sx={{
          width: "100%",
          height: "100%",
          display: "flex",
          flexDirection: "column",
          gap: "8px",
          position: "relative",
        }}
      >
        <Box sx={{ ...topBarStyle, mb: 1, gap: 2 }}>
          <TextField
            fullWidth
            placeholder="Search Indent Records..."
            variant="outlined"
            sx={topBarSearchStyle}
            value={searchTerm}
            onChange={handleSearch}
            InputProps={{
              startAdornment: (
                <InputAdornment position="start">
                  <SearchIcon fontSize="medium" sx={iconButtonStyle} />
                </InputAdornment>
              ),
            }}
          />
          {tableData && tableData?.rows && tableData?.rows.length > 2 && (
            <>
              <Button
                size="small"
                color="info"
                sx={animatedButtonStyle}
                startIcon={<FilterAltIcon />}
                onClick={handleSortByPriority}
              >
                Priority
              </Button>
              <Typography
                variant="body2"
                sx={{
                  color: (theme) => theme.palette.custom.text1,
                  opacity: 0.5,
                }}
              >
                |
              </Typography>
            </>
          )}
          <Button
            size="small"
            startIcon={<AddIcon />}
            onClick={handleAddIndentClick}
            color="info"
            sx={animatedButtonStyle}
          >
            Add Indent
          </Button>
        </Box>
        {loading ? (
          <Box>
            {[...Array(5)].map((_, index) => (
              <Skeleton
                key={index}
                variant="rectangular"
                animation="wave"
                height={40}
                sx={{
                  mb: 2,
                  borderRadius: 2,
                  backgroundColor: (theme) => theme.palette.custom.background1,
                }}
              />
            ))}
          </Box>
        ) : tableData && tableData?.rows && tableData?.rows.length > 0 ? (
          <Box pb={1} sx={{ overflowY: "auto", display: "flex", maxWidth: "100%" }}>
            <DataTable
              table={tableData}
              isSorted={false}
              entriesPerPage={true}
              showTotalEntries={true}
              noEndBorder
            />
          </Box>
        ) : (
          <EmptyStateBox
            icon={BsTable}
            title="Currently there are no created Indents"
            description="Start a new indent by tapping the 'Add Indent' button "
          />
        )}

        {/* Pagination Footer */}
        {tableData && tableData?.rows && tableData?.rows.length > 0 && (
          <PaginationFooter
            currentPage={currentPage}
            rowsPerPage={rowsPerPage}
            totalPages={totalPages}
            totalRecords={totalRecords}
            onPageChange={handlePageChange}
            onRowsPerPageChange={handleRowsPerPageChange}
            loading={false}
          />
        )}
      </Box>
      <IndentFormDialog
        open={isModalOpen}
        onClose={() => setIsModalOpen(false)}
        initialData={editIndentData}
        onSubmit={() => {
          fetchData();
        }}
      />
      <CustomDeleteDialog
        open={isDeleteDialogOpen}
        onClose={() => setIsDeleteDialogOpen(false)}
        onConfirm={handleIndentDelete}
        type="Indent"
        field={indentToDelete ? indentToDelete.department : ""}
      />
      <DescriptionDialog
        open={descriptionDialogOpen}
        onClose={() => setDescriptionDialogOpen(false)}
        description={currentDescription}
      />
      <AttachmentDrawer
        moduleId={indentId}
        module={"INDENT"}
        uploadedBy={user.email}
        uploadedByRole={user.role}
        attachments={attachments}
        open={viewAttachementDialogOpen}
        onClose={() => setViewAttachementDialogOpen(false)}
        onUploadComplete={fetchData}
        user={user}
      />
    </>
  );
};
export default CreateIndnetPage;


import React, { useState, useCallback, useMemo } from "react";
import {
  Box,
  Typography,
  Pagination,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
} from "@mui/material";
import PropTypes from "prop-types";
import toast from "react-hot-toast";
import { SelectDropdown } from "./selectDropdown";
import { dialogStyle, dialogCancelButtonStyle, dialogButtonStyle } from "./styles";
import { CustomTextField } from "./customTextField";
import theme from "assets/theme";
import { BorderColor } from "@mui/icons-material";

const PaginationFooter = ({
  currentPage,
  rowsPerPage,
  totalPages,
  totalRecords,
  onPageChange,
  onRowsPerPageChange,
  loading = false,
  disabled = false,
  showFirstButton = true,
  showLastButton = true,
  color = "primary",
  variant = "outlined",
  customRowsPerPageOptions = null,
  maxCustomValue = 1000,
  minCustomValue = 1,
  position = "absolute",
  backgroundColor,
  borderRadius = 2,
  sx = {},
  ...otherProps
}) => {
  // Custom value dialog state
  const [customValueDialog, setCustomValueDialog] = useState(false);
  const [customValue, setCustomValue] = useState("");

  // Default rows per page options
  const defaultRowsPerPageOptions = useMemo(
    () => [
      { label: "5", value: 5 },
      { label: "10", value: 10 },
      { label: "25", value: 25 },
      { label: "50", value: 50 },
      { label: "100", value: 100 },
      { label: "Custom", value: "custom" },
    ],
    []
  );

  // Use provided options or default ones
  const rowsPerPageOptions = customRowsPerPageOptions || defaultRowsPerPageOptions;

  // Handle page change
  const handlePageChange = useCallback(
    (event, newPage) => {
      if (onPageChange) {
        onPageChange(event, newPage);
      }
    },
    [onPageChange]
  );

  // Handle rows per page change
  const handleRowsPerPageChange = useCallback(
    (event) => {
      const selectedValue = event.target.value;

      if (selectedValue === "Custom" || selectedValue === "custom") {
        setCustomValueDialog(true);
      } else {
        const numericValue = parseInt(selectedValue, 10);
        if (onRowsPerPageChange) {
          onRowsPerPageChange({
            target: { value: numericValue },
            numericValue,
            resetToFirstPage: true,
          });
        }
      }
    },
    [onRowsPerPageChange]
  );

  // Handle custom value submission
  const handleCustomValueSubmit = useCallback(() => {
    const numericValue = parseInt(customValue, 10);

    if (!isNaN(numericValue) && numericValue >= minCustomValue && numericValue <= maxCustomValue) {
      if (onRowsPerPageChange) {
        onRowsPerPageChange({
          target: { value: numericValue },
          numericValue,
          resetToFirstPage: true,
          isCustomValue: true,
        });
      }
      setCustomValueDialog(false);
      setCustomValue("");
      toast.success(`Rows per page set to ${numericValue}`);
    } else {
      toast.error(`Please enter a valid number between ${minCustomValue} and ${maxCustomValue}`);
    }
  }, [customValue, minCustomValue, maxCustomValue, onRowsPerPageChange]);

  // Handle custom value dialog close
  const handleCustomValueCancel = useCallback(() => {
    setCustomValueDialog(false);
    setCustomValue("");
  }, []);

  // Get current rows per page display value
  const currentRowsPerPageDisplay = useMemo(() => {
    const standardOption = rowsPerPageOptions.find((option) => option.value === rowsPerPage);
    return standardOption ? standardOption.label : rowsPerPage.toString();
  }, [rowsPerPage, rowsPerPageOptions]);

  // Calculate display range
  const startRecord = Math.min((currentPage - 1) * rowsPerPage + 1, totalRecords);
  const endRecord = Math.min(currentPage * rowsPerPage, totalRecords);

  // Custom Value Dialog Component
  const CustomValueDialog = useMemo(
    () => (
      <Dialog
        open={customValueDialog}
        onClose={handleCustomValueCancel}
        maxWidth="xs"
        fullWidth
        sx={dialogStyle}
      >
        <DialogTitle
          sx={{ color: (theme) => theme.palette.custom.two, fontSize: "0.9rem !important" }}
        >
          Enter Custom Rows Per Page
        </DialogTitle>
        <DialogContent>
          <CustomTextField
            name="customRowsPerPage"
            type="number"
            placeholder={`Number of rows (${minCustomValue}-${maxCustomValue})`}
            value={customValue}
            onChange={(e) => setCustomValue(e.target.value)}
          />
        </DialogContent>
        <DialogActions sx={{ p: 2, gap: 1 }}>
          <Button onClick={handleCustomValueCancel} size="small" sx={dialogCancelButtonStyle}>
            Cancel
          </Button>
          <Button
            onClick={handleCustomValueSubmit}
            sx={dialogButtonStyle}
            size="small"
            disabled={!customValue || isNaN(parseInt(customValue, 10))}
          >
            Apply
          </Button>
        </DialogActions>
      </Dialog>
    ),
    [
      customValueDialog,
      customValue,
      handleCustomValueCancel,
      handleCustomValueSubmit,
      minCustomValue,
      maxCustomValue,
    ]
  );

  const paginationStyles = {
    "& .MuiPaginationItem-root": {
      color: (theme) => theme.palette.custom.text2,
      borderColor: (theme) => theme.palette.custom.pagination,
      fontSize: "0.8rem",
      "&.Mui-selected": {
        backgroundColor: (theme) => theme.palette.custom.highlight,
        borderColor: (theme) => theme.palette.custom.pagination,
        color: (theme) => theme.palette.custom.dark,
        "&:hover": {
          backgroundColor: (theme) => theme.palette.custom.highlight,
        },
      },
    },
  };

  return (
    <>
      <Box
        sx={{
          position: position,
          bottom: 2,
          left: 0,
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          p: 1,
          width: "100%",
          ...sx,
        }}
        {...otherProps}
      >
        <Box
          sx={{
            backgroundColor: backgroundColor || ((theme) => theme.palette.custom.background1),
            borderRadius: borderRadius,
            width: "100%",
            height: "100%",
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center",
            p: 0.5,
          }}
        >
          <Box sx={{ display: "flex", alignItems: "center", gap: 2 }}>
            <Box sx={{ minWidth: 60 }}>
              <SelectDropdown
                label="rowsPerPage"
                placeholder="Rows per page"
                options={rowsPerPageOptions}
                value={currentRowsPerPageDisplay}
                onChange={handleRowsPerPageChange}
                disabled={disabled || loading}
              />
            </Box>
            <Typography variant="caption" sx={{ color: (theme) => theme.palette.custom.text2 }}>
              {totalRecords > 0
                ? `Showing ${startRecord} to ${endRecord} of ${totalRecords} entries`
                : "No entries to show"}
            </Typography>
          </Box>

          <Pagination
            count={totalPages}
            page={currentPage}
            onChange={handlePageChange}
            color={color}
            variant={variant}
            showFirstButton={showFirstButton}
            showLastButton={showLastButton}
            disabled={loading || disabled}
            sx={paginationStyles}
          />
        </Box>
      </Box>
      {CustomValueDialog}
    </>
  );
};

PaginationFooter.propTypes = {
  // Required props
  currentPage: PropTypes.number.isRequired,
  rowsPerPage: PropTypes.number.isRequired,
  totalPages: PropTypes.number.isRequired,
  totalRecords: PropTypes.number.isRequired,
  onPageChange: PropTypes.func.isRequired,
  onRowsPerPageChange: PropTypes.func.isRequired,

  // Optional props
  loading: PropTypes.bool,
  disabled: PropTypes.bool,
  showFirstButton: PropTypes.bool,
  showLastButton: PropTypes.bool,
  color: PropTypes.oneOf(["primary", "secondary", "standard"]),
  variant: PropTypes.oneOf(["text", "outlined"]),
  customRowsPerPageOptions: PropTypes.arrayOf(
    PropTypes.shape({
      label: PropTypes.string.isRequired,
      value: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).isRequired,
    })
  ),
  maxCustomValue: PropTypes.number,
  minCustomValue: PropTypes.number,
  position: PropTypes.oneOf(["absolute", "relative", "fixed", "static", "sticky"]),
  backgroundColor: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),
  borderRadius: PropTypes.number,
  sx: PropTypes.object,
};

export default PaginationFooter;


{
    "success": true,
    "data": [
        {
            "indentId": "a9351fb4-1170-4580-9a65-df1bb4ee45b3",
            "department": "HR",
            "status": "PENDING",
            "category": "COMPLIANCE_QUERY",
            "description": "eijsdfhj",
            "priority": "LOW",
            "assignedTo": "dmh@gmail.com",
            "comments": "None",
            "dueDate": "2025-06-29T19:48:00.000Z",
            "createdAt": "2025-06-30T05:48:36.817Z",
            "updatedAt": "2025-06-30T05:48:36.817Z",
            "currStep": 0,
            "prevStep": 0,
            "lastStepChangeTime": null,
            "remarkHistory": [],
            "attachments": []
        },
        {
            "indentId": "c700768a-eace-4e99-8233-371b85f3af9a",
            "department": "HR",
            "status": "PENDING",
            "category": "COMPLIANCE_QUERY",
            "description": "sfsjh",
            "priority": "HIGH",
            "assignedTo": "dmh@gmail.com",
            "comments": "None",
            "dueDate": "2025-06-29T20:48:00.000Z",
            "createdAt": "2025-06-30T05:48:14.910Z",
            "updatedAt": "2025-06-30T05:48:14.910Z",
            "currStep": 0,
            "prevStep": 0,
            "lastStepChangeTime": null,
            "remarkHistory": [],
            "attachments": []
        },
        {
            "indentId": "e760f9f7-d346-4cb2-b543-97a34f3f02e2",
            "department": "HR",
            "status": "PENDING",
            "category": "DATA_REQUEST",
            "description": "3538497",
            "priority": "LOW",
            "assignedTo": "dmh@gmail.com",
            "comments": "None",
            "dueDate": "2025-06-29T21:47:00.000Z",
            "createdAt": "2025-06-30T05:47:50.954Z",
            "updatedAt": "2025-06-30T05:47:50.954Z",
            "currStep": 0,
            "prevStep": 0,
            "lastStepChangeTime": null,
            "remarkHistory": [],
            "attachments": []
        }
    ],
    "pagination": {
        "total": 3,
        "page": 1,
        "pageSize": 5,
        "totalPages": 1
    }
}
