import ExcelJS from "exceljs";
import { Response as ExpressResponse } from "express";
import { getNameFromStep, getStepName } from "@/utils/workflow";
import { fetchUsersList } from "@/utils/fetchUsers";
import { prisma } from "@/lib/prisma";
import {
  DEPARTMENT_MAPPING,
  OBSERVATION_PRIORITY_MAPPING,
  OBSERVATION_THEME_MAPPING,
} from "@/constants";

export const generateObservationExcel = async (
  res: ExpressResponse,
  userRole: Position,
  userDepartment: Department,
  filters: {
    status?: "open" | "closed";
    priorityLevel?: observationPriority;
    department?: Department;
    theme?: ObservationTheme;
    search?: string;
    startDate?: string;
    endDate?: string;
  }
) => {
  try {
    const workbook = new ExcelJS.Workbook();
    workbook.creator = "ISE Observation System";
    workbook.created = new Date();

    const worksheet = workbook.addWorksheet("Observations", {
      views: [{ state: "frozen", ySplit: 1 }],
    });

    const headers = [
      "Serial Number",
      "Observation ID",
      "Description",
      "Priority",
      "Theme",
      "Department",
      "Created By",
      "Assigned To",
      "Current Step",
      "Status",
      "Created At",
      "Updated At",
      "Closed Date",
      "Comments",
    ];

    const headerRow = worksheet.addRow(headers);
    headerRow.font = { bold: true, size: 11 };
    headerRow.fill = {
      type: "pattern",
      pattern: "solid",
      fgColor: { argb: "F0F0F0" },
    };

    const where: any = { AND: [{ isDeleted: false }] };

    if (
      (userRole === "DEPARTMENT_MAKER" || userRole === "DEPARTMENT_CHECKER") &&
      userDepartment
    ) {
      where.AND.push({ department: userDepartment });
    }

    if (filters.status === "closed") {
      where.AND.push({ currStep: 4, rejectedStatus: false, openStatus: false });
    } else {
      where.AND.push({ openStatus: true });
    }

    if (filters.priorityLevel) {
      where.AND.push({
        priority: OBSERVATION_PRIORITY_MAPPING[filters.priorityLevel],
      });
    }

    if (filters.department) {
      where.AND.push({ department: DEPARTMENT_MAPPING[filters.department] });
    }

    if (filters.theme) {
      where.AND.push({
        observationTheme: OBSERVATION_THEME_MAPPING[filters.theme],
      });
    }

    if (filters.startDate) {
      where.AND.push({ createdAt: { gte: new Date(filters.startDate) } });
    }

    if (filters.endDate) {
      where.AND.push({ closedDate: { lte: new Date(filters.endDate) } });
    }

    if (filters.search?.trim()) {
      const searchTerm = filters.search.trim();
      where.AND.push({
        OR: [
          { description: { contains: searchTerm, mode: "insensitive" } },
          { comments: { contains: searchTerm, mode: "insensitive" } },
          { observationId: { contains: searchTerm, mode: "insensitive" } },
        ],
      });
    }

    const observations = await prisma.iSEObservations.findMany({
      where,
      orderBy: { updatedAt: "desc" },
    });

    const formatDate = (date: Date | null): string => {
      return date ? date.toLocaleDateString("en-GB") : "N/A";
    };

    for (let index = 0; index < observations.length; index++) {
      const obs = observations[index];
      const pendingWith = getNameFromStep(obs.currStep, obs.prevStep);
      const currentStepName = getStepName(obs.currStep, obs.prevStep, obs.department);
      let assigneeName = "N/A";

      if (pendingWith !== "Closed") {
        try {
          const response = await fetchUsersList({
            ...(pendingWith === "DEPARTMENT_MAKER" || pendingWith === "DEPARTMENT_CHECKER"
              ? { department: obs.department }
              : {}),
            role: pendingWith as Position,
          });

          const userList = response || [];

          if (pendingWith === "DEPARTMENT_MAKER") {
            const match = userList.find((user: any) => user.email === obs.assignedTo);
            if (match) assigneeName = match.name || match.email;
          } else if (userList.length) {
            assigneeName = userList.map((u: any) => u.name || u.email).join(", ");
          }
        } catch (err) {
          console.warn("Error fetching assignee list:", err);
        }
      }

      const row = [
        index + 1,
        obs.observationId || "N/A",
        obs.description || "N/A",
        obs.priority || "N/A",
        obs.observationTheme || "N/A",
        obs.department || "N/A",
        obs.createdBy || "N/A",
        assigneeName,
        currentStepName,
        obs.openStatus ? "Open" : "Closed",
        formatDate(obs.createdAt),
        formatDate(obs.updatedAt),
        formatDate(obs.closedDate),
        obs.comments || "N/A",
      ];

      worksheet.addRow(row);
    }

    worksheet.columns.forEach((column: any) => {
      if (column) column.width = 18;
    });

    await workbook.xlsx.write(res as any);
    res.end();
    return true;
  } catch (error: any) {
    console.error("Error in generateObservationExcel:", error);
    throw new Error(`Observation Excel export failed: ${error.message}`);
  }
};


import ExcelJS from "exceljs";
import { Response as ExpressResponse } from "express";
import { prisma } from "@/lib/prisma";
import { fetchUsersList } from "@/utils/fetchUsers";
import { getNameFromStep, getStepName } from "@/utils/workflow";
import {
  DEPARTMENT_MAPPING,
  INCIDENT_SEVERITY_MAPPING,
  INCIDENT_TYPE_MAPPING,
} from "@/constants";

export const generateIncidentExcel = async (
  res: ExpressResponse,
  userRole: Position,
  userDepartment: Department,
  filters: {
    status?: "open" | "closed" | "rejected";
    severity?: IncidentSeverity;
    department?: Department;
    type?: IncidentType;
    search?: string;
    startDate?: string;
    endDate?: string;
  }
) => {
  try {
    const workbook = new ExcelJS.Workbook();
    workbook.creator = "Incident Reporting System";
    workbook.created = new Date();

    const worksheet = workbook.addWorksheet("Incidents", {
      views: [{ state: "frozen", ySplit: 1 }],
    });

    const headers = [
      "Serial Number",
      "Incident ID",
      "Description",
      "Severity",
      "Type",
      "Department",
      "Created By",
      "Assigned To",
      "Current Step",
      "Status",
      "Created At",
      "Updated At",
      "Closed Date",
      "Comments",
    ];

    const headerRow = worksheet.addRow(headers);
    headerRow.font = { bold: true, size: 11 };
    headerRow.fill = {
      type: "pattern",
      pattern: "solid",
      fgColor: { argb: "F0F0F0" },
    };

    const where: any = { AND: [{ isDeleted: false }] };

    if (
      (userRole === "DEPARTMENT_MAKER" || userRole === "DEPARTMENT_CHECKER") &&
      userDepartment
    ) {
      where.AND.push({ department: userDepartment });
    }

    if (filters.status === "closed") {
      where.AND.push({ currStep: 4, rejectedStatus: false, openStatus: false });
    } else if (filters.status === "rejected") {
      where.AND.push({ rejectedStatus: true });
    } else {
      where.AND.push({ openStatus: true });
    }

    if (filters.severity) {
      where.AND.push({ severity: INCIDENT_SEVERITY_MAPPING[filters.severity] });
    }

    if (filters.department) {
      where.AND.push({ department: DEPARTMENT_MAPPING[filters.department] });
    }

    if (filters.type) {
      where.AND.push({ type: INCIDENT_TYPE_MAPPING[filters.type] });
    }

    if (filters.startDate) {
      where.AND.push({ createdAt: { gte: new Date(filters.startDate) } });
    }

    if (filters.endDate) {
      where.AND.push({ closedDate: { lte: new Date(filters.endDate) } });
    }

    if (filters.search?.trim()) {
      const searchTerm = filters.search.trim();
      where.AND.push({
        OR: [
          { department: { contains: searchTerm, mode: "insensitive" } },
          { comments: { contains: searchTerm, mode: "insensitive" } },
          { incidentId: { contains: searchTerm, mode: "insensitive" } },
        ],
      });
    }

    const incidents = await prisma.incidentReporting.findMany({
      where,
      orderBy: { updatedAt: "desc" },
    });

    const formatDate = (date: Date | null): string => {
      return date ? date.toLocaleDateString("en-GB") : "N/A";
    };

    for (let index = 0; index < incidents.length; index++) {
      const incident = incidents[index];
      const pendingWith = getNameFromStep(incident.currStep, incident.prevStep);
      const currentStepName = getStepName(incident.currStep, incident.prevStep, incident.department);
      let assigneeName = "N/A";

      if (pendingWith !== "Closed") {
        try {
          const response = await fetchUsersList({
            ...(pendingWith === "DEPARTMENT_MAKER" || pendingWith === "DEPARTMENT_CHECKER"
              ? { department: incident.department }
              : {}),
            role: pendingWith as Position,
          });

          const userList = response || [];

          if (pendingWith === "DEPARTMENT_MAKER") {
            const match = userList.find((user: any) => user.email === incident.assignedTo);
            if (match) assigneeName = match.name || match.email;
          } else if (userList.length) {
            assigneeName = userList.map((u: any) => u.name || u.email).join(", ");
          }
        } catch (err) {
          console.warn("Error fetching assignee list:", err);
        }
      }

      const row = [
        index + 1,
        incident.incidentId || "N/A",
        incident.description || "N/A",
        incident.severity || "N/A",
        incident.type || "N/A",
        incident.department || "N/A",
        incident.createdBy || "N/A",
        assigneeName,
        currentStepName,
        incident.rejectedStatus
          ? "Rejected"
          : incident.openStatus
          ? "Open"
          : "Closed",
        formatDate(incident.createdAt),
        formatDate(incident.updatedAt),
        formatDate(incident.closedDate),
        incident.comments || "N/A",
      ];

      worksheet.addRow(row);
    }

    worksheet.columns.forEach((column: any) => {
      if (column) column.width = 18;
    });

    await workbook.xlsx.write(res as any);
    res.end();
    return true;
  } catch (error: any) {
    console.error("Error in generateIncidentExcel:", error);
    throw new Error(`Incident Excel export failed: ${error.message}`);
  }
};
