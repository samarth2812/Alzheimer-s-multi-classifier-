
import { useEffect, useState, useMemo, useCallback } from "react";
import toast from "react-hot-toast";
import { useSelector, useDispatch } from "react-redux";
import debounce from "lodash.debounce";
import { apiRequest } from "../../axios/apiRequest";
import { fetchNotifications } from "features/notificationSlice";

export const useIndentManagement = (pageType) => {
  // Common state
  const [data, setData] = useState([]);
  const [searchTerm, setSearchTerm] = useState("");
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editIndentData, setEditIndentData] = useState(null);
  const [indentToDelete, setIndentToDelete] = useState(null);
  const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false);
  const [descriptionDialogOpen, setDescriptionDialogOpen] = useState(false);
  const [currentDescription, setCurrentDescription] = useState("");
  const [loading, setLoading] = useState(true);
  const [formData, setFormData] = useState({});
  const [viewAttachementDialogOpen, setViewAttachementDialogOpen] = useState(false);
  const [attachments, setAttachments] = useState([]);
  const [indentId, setIndentId] = useState("");

  // Pagination state
  const [currentPage, setCurrentPage] = useState(1);
  const [rowsPerPage, setRowsPerPage] = useState(5);
  const [totalRecords, setTotalRecords] = useState(1);
  const [totalPages, setTotalPages] = useState(1);

  const user = useSelector((state) => state.user.user);
  const dispatch = useDispatch();

  // API endpoint configuration based on page type
  const getApiEndpoint = useCallback((searchQuery = "") => {
    const baseUrl = window._env_?.REACT_APP_BACKEND_URL || process.env.REACT_APP_BACKEND_URL;
    const role = user?.role;
    const department = user?.department;
    const pagination = `page=${currentPage}&limit=${rowsPerPage}`;
    const searchParam = searchQuery ? `&search=${encodeURIComponent(searchQuery)}` : "";

    switch (pageType) {
      case "created":
        return `${baseUrl}/api/v1/indents/${role}/created?${pagination}${searchParam}`;
      case "latest":
        return role === "COMPLIANCE_CHECKER"
          ? `${baseUrl}/api/v1/indents/${role}/latest?${pagination}${searchParam}`
          : `${baseUrl}/api/v1/indents/${role}/latest/${department}?${pagination}${searchParam}`;
      case "closure":
        return `${baseUrl}/api/v1/indents/${role}/closure?${pagination}${searchParam}`;
      case "rejected":
        return role === "COMPLIANCE_MAKER"
          ? `${baseUrl}/api/v1/indents/${role}/rejected?${pagination}${searchParam}`
          : `${baseUrl}/api/v1/indents/${role}/rejected/${department}?${pagination}${searchParam}`;
      default:
        return `${baseUrl}/api/v1/indents/${role}/created?${pagination}${searchParam}`;
    }
  }, [pageType, user?.role, user?.department, currentPage, rowsPerPage]);

  // Fetch data function
  const fetchData = useCallback(async (searchQuery = "") => {
    if (!user?.role) return;

    setLoading(true);
    try {
      const endpoint = getApiEndpoint(searchQuery);
      const response = await apiRequest("GET", endpoint);

      setData(response.data.data);
      setTotalRecords(response.data.pagination.total);
      setTotalPages(response.data.pagination.totalPages);

      // Update attachments if indentId exists
      if (indentId) {
        const updatedIndent = response.data.data.find((indent) => indent.indentId === indentId);
        if (updatedIndent) {
          setAttachments(updatedIndent.attachments || []);
        }
      }
    } catch (error) {
      toast.error("Failed to fetch Indent");
    } finally {
      setLoading(false);
    }
  }, [getApiEndpoint, indentId, user?.role]);

  // Debounced search function for backend API calls
  const debouncedSearch = useMemo(
    () =>
      debounce((searchQuery) => {
        // Only reset to first page if we're not already on first page
        if (currentPage !== 1) {
          setCurrentPage(1);
        } else {
          fetchData(searchQuery);
        }
      }, 500), // Increased debounce time for API calls
    [fetchData, currentPage]
  );

  // Initial data fetch
  useEffect(() => {
    if (user?.role) {
      fetchData();
    }
  }, [user?.role]);

  // Search effect - now triggers backend search
  useEffect(() => {
    const trimmedSearchTerm = searchTerm.trim();
    
    if (trimmedSearchTerm) {
      debouncedSearch(trimmedSearchTerm);
    } else {
      // If search is cleared, fetch data without search query
      debouncedSearch.cancel();
      if (currentPage !== 1) {
        setCurrentPage(1);
      } else {
        fetchData();
      }
    }

    return () => debouncedSearch.cancel();
  }, [searchTerm, debouncedSearch, fetchData, currentPage]);

  // Refetch data when pagination changes (but not when search term changes)
  useEffect(() => {
    const trimmedSearchTerm = searchTerm.trim();
    fetchData(trimmedSearchTerm);
  }, [currentPage, rowsPerPage]);

  // Separate effect for initial data fetch
  useEffect(() => {
    if (user?.role) {
      fetchData();
    }
  }, [user?.role]);

  // Common handlers
  const handleSearch = useCallback((event) => {
    setSearchTerm(event.target.value);
  }, []);

  const handleAddIndentClick = useCallback(() => {
    setEditIndentData(null);
    setIsModalOpen(true);
  }, []);

  const handleChange = useCallback((e, indentId) => {
    const { name, value } = e.target;
    setFormData((prev) => ({
      ...prev,
      [indentId]: {
        ...prev[indentId],
        [name]: value,
      },
    }));
  }, []);

  const handleIndentDelete = useCallback(async () => {
    if (!indentToDelete) return;

    try {
      const deleteIndentUrl = `${window._env_?.REACT_APP_BACKEND_URL || process.env.REACT_APP_BACKEND_URL}/api/v1/indents/${indentToDelete.indentId}`;
      const result = await apiRequest("DELETE", deleteIndentUrl);

      if (result.status === 200 || result.status === 204) {
        toast.success("Indent Deleted Successfully");
        // Refetch data after deletion
        const trimmedSearchTerm = searchTerm.trim();
        fetchData(trimmedSearchTerm);
      }
    } catch (error) {
      console.error("Error deleting indent:", error);
    } finally {
      setIsDeleteDialogOpen(false);
    }
  }, [indentToDelete, fetchData, searchTerm]);

  const handleSubmitIndent = useCallback(
    async (indentId, department) => {
      try {
        const isComplianceDepartment = department === "COMPLIANCE";
        const payload = {
          updatedFields: {
            type: "WORKFLOW_UPDATE",
            rejectedStatus:
              pageType === "latest" || pageType === "rejected" || pageType === "closure"
                ? formData[indentId]?.approvalStatus === "approve"
                  ? false
                  : true
                : false,
          },
        };

        const result = await apiRequest(
          "PUT",
          `${window._env_?.REACT_APP_BACKEND_URL || process.env.REACT_APP_BACKEND_URL}/api/v1/indents/${user.role}/${department}/${indentId}`,
          payload
        );

        if (result.status === 200 || result.status === 204) {
          // Success message logic based on page type and approval status
          if (pageType === "created") {
            toast.success("Indent Sent to Compliance Checker Successfully");
          } else if (pageType === "latest") {
            const approvalStatus = formData[indentId]?.approvalStatus;
            // Add specific success messages based on role and approval status
            if (isComplianceDepartment) {
              if (approvalStatus === "approve") {
                toast.success("Indent Sent to back to Compliance Maker for Closure Successfully");
              } else {
                toast.success("Indent Sent to back to Compliance Maker Successfully");
              }
            } else {
              if (approvalStatus === "approve") {
                if (user.role === "COMPLIANCE_CHECKER") {
                  toast.success("Indent Sent to Department Maker Successfully");
                } else if (user.role === "DEPARTMENT_MAKER") {
                  toast.success("Indent Sent to Department Checker Successfully");
                } else {
                  toast.success("Indent Sent to Compliance Maker Successfully");
                }
              } else {
                if (user.role === "COMPLIANCE_CHECKER") {
                  toast.success("Indent Sent to back to Compliance Maker Successfully");
                } else if (user.role === "DEPARTMENT_MAKER") {
                  toast.success("Indent Sent to back to Compliance Maker Successfully");
                } else {
                  toast.success("Indent Sent to back to Department Maker Successfully");
                }
              }
            }
          } else if (pageType === "rejected") {
            if (formData[indentId]?.approvalStatus === "approve") {
              if (user.role === "COMPLIANCE_MAKER") {
                toast.success("Indent Sent to Compliance Checker Successfully");
              } else if (user.role === "DEPARTMENT_MAKER") {
                toast.success("Indent Sent to Department Checker Successfully");
              } else {
                toast.success("Indent Sent Successfully");
              }
            } else {
              if (user.role === "COMPLIANCE_MAKER") {
                toast.success("Indent Sent to back to Department Maker Successfully");
              } else if (user.role === "DEPARTMENT_MAKER") {
                toast.success("Indent Sent to back to Compliance Maker Successfully");
              } else {
                toast.success("Indent Sent Successfully");
              }
            }
          } else if (pageType === "closure") {
            if (formData[indentId]?.approvalStatus === "approve") {
              if (user.role === "COMPLIANCE_MAKER") {
                toast.success("Indent Sent For Closure to Compliance Checker Successfully");
              } else if (user.role === "COMPLIANCE_CHECKER") {
                toast.success("Indent Closed Successfully");
              }
            } else if (formData[indentId]?.approvalStatus !== "approve") {
              if (user.role === "COMPLIANCE_MAKER") {
                toast.success("Indent Sent Back to Department Maker Successfully");
              } else if (user.role === "COMPLIANCE_CHECKER") {
                toast.success("Indent Sent Back to Compliance Maker Successfully");
              }
            } else {
              toast.success("Indent Sent to back to Compliance Checker Successfully");
            }
          }
        }

        // Refetch data after submit
        const trimmedSearchTerm = searchTerm.trim();
        fetchData(trimmedSearchTerm);
        dispatch(fetchNotifications());
      } catch (error) {
        toast.error("An error occurred while submitting the Indent.");
      }
    },
    [pageType, formData, user.role, fetchData, dispatch, searchTerm]
  );

  const handleSubmitRemark = useCallback(
    async (indentId, remarkData) => {
      try {
        const result = await apiRequest(
          "POST",
          `${window._env_?.REACT_APP_BACKEND_URL || process.env.REACT_APP_BACKEND_URL}/api/v1/indents/remarks/${indentId}`,
          remarkData
        );

        if (result.status === 201 || result.status === 204) {
          toast.success("Indent Remark Added Successfully");
        }
        // Refetch data after remark submission
        const trimmedSearchTerm = searchTerm.trim();
        fetchData(trimmedSearchTerm);
      } catch (error) {
        toast.error("An error occurred while submitting the Remark.");
      }
    },
    [fetchData, searchTerm]
  );

  const handleEditRemark = useCallback(
    async (remarkId, remarkContent) => {
      try {
        const result = await apiRequest(
          "PUT",
          `${window._env_?.REACT_APP_BACKEND_URL || process.env.REACT_APP_BACKEND_URL}/api/v1/indents/remarks/${remarkId}`,
          { remarkContent }
        );

        if (result.status === 201 || result.status === 204) {
          toast.success("Indent Remark Updated Successfully");
        }
        // Refetch data after remark edit
        const trimmedSearchTerm = searchTerm.trim();
        fetchData(trimmedSearchTerm);
      } catch (error) {
        toast.error("An error occurred while submitting the Remark.");
      }
    },
    [fetchData, searchTerm]
  );

  const handleSortByPriority = useCallback(() => {
    const priorityOrder = { HIGH: 3, MEDIUM: 2, LOW: 1 };
    const sortedData = [...data].sort((a, b) => {
      return priorityOrder[b.priority] - priorityOrder[a.priority];
    });
    setData(sortedData);
  }, [data]);

  const handlePageChange = useCallback((event, newPage) => {
    setCurrentPage(newPage);
  }, []);

  const handleRowsPerPageChange = useCallback((event) => {
    const { numericValue, resetToFirstPage } = event;
    setRowsPerPage(numericValue);
    if (resetToFirstPage) {
      setCurrentPage(1);
    }
  }, []);

  // Utility functions
  const formatDateTime = useCallback((dateString) => {
    return new Date(dateString).toLocaleString("en-GB", {
      day: "2-digit",
      month: "2-digit",
      year: "numeric",
      hour: "2-digit",
      minute: "2-digit",
      hour12: true,
    });
  }, []);

  // Remove filteredData and displayData logic since search is now handled by backend
  const displayData = data;

  return {
    // State
    data,
    searchTerm,
    isModalOpen,
    setIsModalOpen,
    editIndentData,
    setEditIndentData,
    indentToDelete,
    setIndentToDelete,
    isDeleteDialogOpen,
    setIsDeleteDialogOpen,
    descriptionDialogOpen,
    setDescriptionDialogOpen,
    currentDescription,
    setCurrentDescription,
    loading,
    formData,
    setFormData,
    viewAttachementDialogOpen,
    setViewAttachementDialogOpen,
    attachments,
    setAttachments,
    indentId,
    setIndentId,
    currentPage,
    rowsPerPage,
    totalRecords,
    totalPages,
    displayData,
    user,

    // Handlers
    handleSearch,
    handleAddIndentClick,
    handleChange,
    handleIndentDelete,
    handleSubmitIndent,
    handleSubmitRemark,
    handleEditRemark,
    handleSortByPriority,
    handlePageChange,
    handleRowsPerPageChange,
    fetchData,
    formatDateTime,
  };
};
