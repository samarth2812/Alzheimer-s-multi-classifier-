import { useEffect, useState, useMemo, useCallback, useRef } from "react";
import toast from "react-hot-toast";
import { useSelector, useDispatch } from "react-redux";
import debounce from "lodash.debounce";
import { apiRequest } from "../../axios/apiRequest";
import { fetchNotifications } from "features/notificationSlice";

export const useIndentManagement = (pageType) => {
  // Common state
  const [data, setData] = useState([]);
  const [searchTerm, setSearchTerm] = useState("");
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editIndentData, setEditIndentData] = useState(null);
  const [indentToDelete, setIndentToDelete] = useState(null);
  const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false);
  const [descriptionDialogOpen, setDescriptionDialogOpen] = useState(false);
  const [currentDescription, setCurrentDescription] = useState("");
  const [loading, setLoading] = useState(true);
  const [formData, setFormData] = useState({});
  const [viewAttachementDialogOpen, setViewAttachementDialogOpen] = useState(false);
  const [attachments, setAttachments] = useState([]);
  const [indentId, setIndentId] = useState("");

  // Pagination state
  const [currentPage, setCurrentPage] = useState(1);
  const [rowsPerPage, setRowsPerPage] = useState(5);
  const [totalRecords, setTotalRecords] = useState(1);
  const [totalPages, setTotalPages] = useState(1);

  const user = useSelector((state) => state.user.user);
  const dispatch = useDispatch();

  // Ref to track if we're in the middle of a pagination change
  const paginationChangeRef = useRef(false);

  // API endpoint configuration based on page type
  const getApiEndpoint = useCallback((searchQuery = "", page = currentPage, limit = rowsPerPage) => {
    const baseUrl = window._env_?.REACT_APP_BACKEND_URL || process.env.REACT_APP_BACKEND_URL;
    const role = user?.role;
    const department = user?.department;
    const pagination = `page=${page}&limit=${limit}`;
    const searchParam = searchQuery ? `&search=${encodeURIComponent(searchQuery)}` : "";

    switch (pageType) {
      case "created":
        return `${baseUrl}/api/v1/indents/${role}/created?${pagination}${searchParam}`;
      case "latest":
        return role === "COMPLIANCE_CHECKER"
          ? `${baseUrl}/api/v1/indents/${role}/latest?${pagination}${searchParam}`
          : `${baseUrl}/api/v1/indents/${role}/latest/${department}?${pagination}${searchParam}`;
      case "closure":
        return `${baseUrl}/api/v1/indents/${role}/closure?${pagination}${searchParam}`;
      case "rejected":
        return role === "COMPLIANCE_MAKER"
          ? `${baseUrl}/api/v1/indents/${role}/rejected?${pagination}${searchParam}`
          : `${baseUrl}/api/v1/indents/${role}/rejected/${department}?${pagination}${searchParam}`;
      default:
        return `${baseUrl}/api/v1/indents/${role}/created?${pagination}${searchParam}`;
    }
  }, [pageType, user?.role, user?.department]);

  // Main fetch function that accepts all parameters
  const fetchDataWithParams = useCallback(async (searchQuery = "", page = 1, limit = 5) => {
    if (!user?.role) return;

    setLoading(true);
    try {
      const endpoint = getApiEndpoint(searchQuery, page, limit);
      const response = await apiRequest("GET", endpoint);

      setData(response.data.data);
      setTotalRecords(response.data.pagination.total);
      setTotalPages(response.data.pagination.totalPages);

      // Update attachments if indentId exists
      if (indentId) {
        const updatedIndent = response.data.data.find((indent) => indent.indentId === indentId);
        if (updatedIndent) {
          setAttachments(updatedIndent.attachments || []);
        }
      }
    } catch (error) {
      toast.error("Failed to fetch Indent");
    } finally {
      setLoading(false);
    }
  }, [getApiEndpoint, indentId, user?.role]);

  // Fetch data function using current state
  const fetchData = useCallback(async (searchQuery = "") => {
    await fetchDataWithParams(searchQuery, currentPage, rowsPerPage);
  }, [fetchDataWithParams, currentPage, rowsPerPage]);

  // Separate function for fetching with search
  const fetchDataWithSearch = useCallback(async (searchQuery = "") => {
    await fetchDataWithParams(searchQuery, currentPage, rowsPerPage);
  }, [fetchDataWithParams, currentPage, rowsPerPage]);

  // Debounced search function for backend API calls
  const debouncedSearch = useMemo(
    () =>
      debounce(async (searchQuery) => {
        setCurrentPage(1);
        // Wait for next tick to ensure currentPage state is updated
        setTimeout(() => {
          fetchDataWithParams(searchQuery, 1, rowsPerPage);
        }, 0);
      }, 500),
    [fetchDataWithParams, rowsPerPage]
  );

  // Effect for initial load and pagination changes
  useEffect(() => {
    if (!user?.role) return;
    
    const trimmedSearchTerm = searchTerm.trim();
    
    // Only fetch if not in the middle of a pagination change
    if (!paginationChangeRef.current) {
      fetchDataWithParams(trimmedSearchTerm, currentPage, rowsPerPage);
    }
    
    // Reset the pagination change flag
    paginationChangeRef.current = false;
  }, [user?.role, currentPage, rowsPerPage, fetchDataWithParams]);

  // Effect only for search term changes
  useEffect(() => {
    if (!user?.role) return;
    
    const trimmedSearchTerm = searchTerm.trim();
    
    if (trimmedSearchTerm) {
      debouncedSearch(trimmedSearchTerm);
    } else {
      debouncedSearch.cancel();
      if (currentPage !== 1) {
        setCurrentPage(1);
      } else {
        fetchDataWithParams('', 1, rowsPerPage);
      }
    }

    return () => debouncedSearch.cancel();
  }, [searchTerm, user?.role, debouncedSearch, currentPage, rowsPerPage, fetchDataWithParams]);

  // Common handlers
  const handleSearch = useCallback((event) => {
    setSearchTerm(event.target.value);
  }, []);

  const handleAddIndentClick = useCallback(() => {
    setEditIndentData(null);
    setIsModalOpen(true);
  }, []);

  const handleChange = useCallback((e, indentId) => {
    const { name, value } = e.target;
    setFormData((prev) => ({
      ...prev,
      [indentId]: {
        ...prev[indentId],
        [name]: value,
      },
    }));
  }, []);

  const handleIndentDelete = useCallback(async () => {
    if (!indentToDelete) return;

    try {
      const deleteIndentUrl = `${window._env_?.REACT_APP_BACKEND_URL || process.env.REACT_APP_BACKEND_URL}/api/v1/indents/${indentToDelete.indentId}`;
      const result = await apiRequest("DELETE", deleteIndentUrl);

      if (result.status === 200 || result.status === 204) {
        toast.success("Indent Deleted Successfully");
        // Refetch data after deletion
        const trimmedSearchTerm = searchTerm.trim();
        await fetchDataWithParams(trimmedSearchTerm, currentPage, rowsPerPage);
      }
    } catch (error) {
      console.error("Error deleting indent:", error);
    } finally {
      setIsDeleteDialogOpen(false);
    }
  }, [indentToDelete, fetchDataWithParams, searchTerm, currentPage, rowsPerPage]);

  const handleSubmitIndent = useCallback(
    async (indentId, department) => {
      try {
        const isComplianceDepartment = department === "COMPLIANCE";
        const payload = {
          updatedFields: {
            type: "WORKFLOW_UPDATE",
            rejectedStatus:
              pageType === "latest" || pageType === "rejected" || pageType === "closure"
                ? formData[indentId]?.approvalStatus === "approve"
                  ? false
                  : true
                : false,
          },
        };

        const result = await apiRequest(
          "PUT",
          `${window._env_?.REACT_APP_BACKEND_URL || process.env.REACT_APP_BACKEND_URL}/api/v1/indents/${user.role}/${department}/${indentId}`,
          payload
        );

        if (result.status === 200 || result.status === 204) {
          // Success message logic based on page type and approval status
          if (pageType === "created") {
            toast.success("Indent Sent to Compliance Checker Successfully");
          } else if (pageType === "latest") {
            const approvalStatus = formData[indentId]?.approvalStatus;
            // Add specific success messages based on role and approval status
            if (isComplianceDepartment) {
              if (approvalStatus === "approve") {
                toast.success("Indent Sent to back to Compliance Maker for Closure Successfully");
              } else {
                toast.success("Indent Sent to back to Compliance Maker Successfully");
              }
            } else {
              if (approvalStatus === "approve") {
                if (user.role === "COMPLIANCE_CHECKER") {
                  toast.success("Indent Sent to Department Maker Successfully");
                } else if (user.role === "DEPARTMENT_MAKER") {
                  toast.success("Indent Sent to Department Checker Successfully");
                } else {
                  toast.success("Indent Sent to Compliance Maker Successfully");
                }
              } else {
                if (user.role === "COMPLIANCE_CHECKER") {
                  toast.success("Indent Sent to back to Compliance Maker Successfully");
                } else if (user.role === "DEPARTMENT_MAKER") {
                  toast.success("Indent Sent to back to Compliance Maker Successfully");
                } else {
                  toast.success("Indent Sent to back to Department Maker Successfully");
                }
              }
            }
          } else if (pageType === "rejected") {
            if (formData[indentId]?.approvalStatus === "approve") {
              if (user.role === "COMPLIANCE_MAKER") {
                toast.success("Indent Sent to Compliance Checker Successfully");
              } else if (user.role === "DEPARTMENT_MAKER") {
                toast.success("Indent Sent to Department Checker Successfully");
              } else {
                toast.success("Indent Sent Successfully");
              }
            } else {
              if (user.role === "COMPLIANCE_MAKER") {
                toast.success("Indent Sent to back to Department Maker Successfully");
              } else if (user.role === "DEPARTMENT_MAKER") {
                toast.success("Indent Sent to back to Compliance Maker Successfully");
              } else {
                toast.success("Indent Sent Successfully");
              }
            }
          } else if (pageType === "closure") {
            if (formData[indentId]?.approvalStatus === "approve") {
              if (user.role === "COMPLIANCE_MAKER") {
                toast.success("Indent Sent For Closure to Compliance Checker Successfully");
              } else if (user.role === "COMPLIANCE_CHECKER") {
                toast.success("Indent Closed Successfully");
              }
            } else if (formData[indentId]?.approvalStatus !== "approve") {
              if (user.role === "COMPLIANCE_MAKER") {
                toast.success("Indent Sent Back to Department Maker Successfully");
              } else if (user.role === "COMPLIANCE_CHECKER") {
                toast.success("Indent Sent Back to Compliance Maker Successfully");
              }
            } else {
              toast.success("Indent Sent to back to Compliance Checker Successfully");
            }
          }
        }

        // Refetch data after submit
        const trimmedSearchTerm = searchTerm.trim();
        await fetchDataWithParams(trimmedSearchTerm, currentPage, rowsPerPage);
        dispatch(fetchNotifications());
      } catch (error) {
        toast.error("An error occurred while submitting the Indent.");
      }
    },
    [pageType, formData, user.role, fetchDataWithParams, dispatch, searchTerm, currentPage, rowsPerPage]
  );

  const handleSubmitRemark = useCallback(
    async (indentId, remarkData) => {
      try {
        const result = await apiRequest(
          "POST",
          `${window._env_?.REACT_APP_BACKEND_URL || process.env.REACT_APP_BACKEND_URL}/api/v1/indents/remarks/${indentId}`,
          remarkData
        );

        if (result.status === 201 || result.status === 204) {
          toast.success("Indent Remark Added Successfully");
        }
        // Refetch data after remark submission
        const trimmedSearchTerm = searchTerm.trim();
        await fetchDataWithParams(trimmedSearchTerm, currentPage, rowsPerPage);
      } catch (error) {
        toast.error("An error occurred while submitting the Remark.");
      }
    },
    [fetchDataWithParams, searchTerm, currentPage, rowsPerPage]
  );

  const handleEditRemark = useCallback(
    async (remarkId, remarkContent) => {
      try {
        const result = await apiRequest(
          "PUT",
          `${window._env_?.REACT_APP_BACKEND_URL || process.env.REACT_APP_BACKEND_URL}/api/v1/indents/remarks/${remarkId}`,
          { remarkContent }
        );

        if (result.status === 201 || result.status === 204) {
          toast.success("Indent Remark Updated Successfully");
        }
        // Refetch data after remark edit
        const trimmedSearchTerm = searchTerm.trim();
        await fetchDataWithParams(trimmedSearchTerm, currentPage, rowsPerPage);
      } catch (error) {
        toast.error("An error occurred while submitting the Remark.");
      }
    },
    [fetchDataWithParams, searchTerm, currentPage, rowsPerPage]
  );

  const handleSortByPriority = useCallback(() => {
    const priorityOrder = { HIGH: 3, MEDIUM: 2, LOW: 1 };
    const sortedData = [...data].sort((a, b) => {
      return priorityOrder[b.priority] - priorityOrder[a.priority];
    });
    setData(sortedData);
  }, [data]);

  const handlePageChange = useCallback((event, newPage) => {
    paginationChangeRef.current = true;
    setCurrentPage(newPage);
  }, []);

  const handleRowsPerPageChange = useCallback(async (event) => {
    const { numericValue, resetToFirstPage } = event;
    
    paginationChangeRef.current = true;
    setRowsPerPage(numericValue);
    
    const newPage = resetToFirstPage ? 1 : currentPage;
    if (resetToFirstPage) {
      setCurrentPage(1);
    }
    
    // Immediately fetch data with new parameters
    const trimmedSearchTerm = searchTerm.trim();
    await fetchDataWithParams(trimmedSearchTerm, newPage, numericValue);
  }, [currentPage, searchTerm, fetchDataWithParams]);

  // Utility functions
  const formatDateTime = useCallback((dateString) => {
    return new Date(dateString).toLocaleString("en-GB", {
      day: "2-digit",
      month: "2-digit",
      year: "numeric",
      hour: "2-digit",
      minute: "2-digit",
      hour12: true,
    });
  }, []);

  // Remove filteredData and displayData logic since search is now handled by backend
  const displayData = data;

  return {
    // State
    data,
    searchTerm,
    isModalOpen,
    setIsModalOpen,
    editIndentData,
    setEditIndentData,
    indentToDelete,
    setIndentToDelete,
    isDeleteDialogOpen,
    setIsDeleteDialogOpen,
    descriptionDialogOpen,
    setDescriptionDialogOpen,
    currentDescription,
    setCurrentDescription,
    loading,
    formData,
    setFormData,
    viewAttachementDialogOpen,
    setViewAttachementDialogOpen,
    attachments,
    setAttachments,
    indentId,
    setIndentId,
    currentPage,
    rowsPerPage,
    totalRecords,
    totalPages,
    displayData,
    user,

    // Handlers
    handleSearch,
    handleAddIndentClick,
    handleChange,
    handleIndentDelete,
    handleSubmitIndent,
    handleSubmitRemark,
    handleEditRemark,
    handleSortByPriority,
    handlePageChange,
    handleRowsPerPageChange,
    fetchData,
    fetchDataWithSearch,
    formatDateTime,
  };
};
