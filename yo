  // Pagination state
  const [data, setData] = useState([]);
  const [currentPage, setCurrentPage] = useState(1);
  const [rowsPerPage, setRowsPerPage] = useState(10);
  const [totalRecords, setTotalRecords] = useState(1);
  const [totalPages, setTotalPages] = useState(1);

  const fetchData = async () => {
    setLoading(true);
    try {
      const response = await apiRequest(
        "GET",
        `${process.env.REACT_APP_BACKEND_URL}/api/v1/indents/${user?.role}/created?page=${currentPage}&limit=${rowsPerPage}`
      );
      setData(response.data);
      setTotalRecords(response.pagination.total);
      setTotalPages(response.pagination.totalPages);

      if (indentId) {
        const updatedIndent = response.data.find((indent) => indent.indentId === indentId);
        if (updatedIndent) {
          setAttachments(updatedIndent.attachments || []);
        }
      }
    } catch {
      toast.error("Failed to fetch Indent");
    } finally {
      setLoading(false);
    }
  };

  const formatTableData = (rawData) => {
    const columns = [
      { Header: "S.No", accessor: "serialNumber", width: "5%", align: "center" },
      { Header: "Department", accessor: "department", width: "15%", align: "left" },
      { Header: "Description", accessor: "description", width: "15%", align: "left" },
      { Header: "Status", accessor: "status", width: "10%", align: "center" },
      { Header: "Priority", accessor: "priority", width: "15%", align: "left" },
      { Header: "Assigned To", accessor: "assignedTo", width: "10%", align: "center" },
      { Header: "Due Date", accessor: "dueDate", width: "10%", align: "center" },
      { Header: "Created At", accessor: "createdAt", width: "10%", align: "center" },
      { Header: "Comments", accessor: "comments", width: "15%", align: "left" },
      { Header: "Actions", accessor: "actions", width: "15%", align: "center" },
      { Header: "Attachments", accessor: "attachments", width: "15%", align: "center" },
      { Header: "Approval", accessor: "approval", width: "10%", align: "center" },
      { Header: "Remarks", accessor: "remarks", width: "15%", align: "center" },
      { Header: "Submit", accessor: "submit", width: "10%", align: "center" },
    ];

    const rows = rawData.map((item, index) => ({
      serialNumber: (
        <MDTypography
          variant="button"
          sx={{ color: (theme) => theme.palette.custom.text2, fontSize: "0.7rem !important" }}
        >
          {page * rowsPerPage + index + 1}
        </MDTypography>
      ),
      department: (
        <MDTypography
          variant="button"
          sx={{ color: (theme) => theme.palette.custom.text2, fontSize: "0.7rem !important" }}
        >
          {item.department.replace(/_/g, " ")}
        </MDTypography>
      ),
      description: (
        <Tooltip title="Preview Description">
          <IconButton
            sx={iconButtonStyle}
            onClick={() => {
              setCurrentDescription(item.description);
              setDescriptionDialogOpen(true);
            }}
          >
            <Visibility />
          </IconButton>
        </Tooltip>
      ),
      status: (
        <MDTypography
          variant="button"
          sx={{ color: (theme) => theme.palette.custom.text2, fontSize: "0.7rem !important" }}
        >
          {item.status.replace(/_/g, " ")}
        </MDTypography>
      ),
      priority: (
        <MDTypography
          variant="button"
          sx={{ color: (theme) => theme.palette.custom.text2, fontSize: "0.7rem !important" }}
        >
          {item.priority.replace(/_/g, " ")}
        </MDTypography>
      ),
      assignedTo: (
        <MDTypography
          variant="button"
          sx={{ color: (theme) => theme.palette.custom.text2, fontSize: "0.7rem !important" }}
        >
          {item.assignedTo}
        </MDTypography>
      ),
      dueDate: (
        <MDTypography
          variant="button"
          sx={{ color: (theme) => theme.palette.custom.text2, fontSize: "0.7rem !important" }}
        >
          {formatDateTime(item.dueDate)}
        </MDTypography>
      ),
      createdAt: (
        <MDTypography
          variant="button"
          sx={{ color: (theme) => theme.palette.custom.text2, fontSize: "0.7rem !important" }}
        >
          {formatDateTime(item.createdAt)}
        </MDTypography>
      ),
      comments: (
        <InputWithDialog
          value={item.comments}
          dialogTitle="Comments"
          dialogPlaceholder="Comments"
          cancelButtonLabel="Cancel"
          icon={VisibilityIcon}
          name="name"
          type="text"
          callOnSave={false}
          isDisabled={true}
        />
      ),
      actions: (
        <Stack direction="row" spacing={1} justifyContent="center">
          <Tooltip title="Edit Indent Details">
            <IconButton
              sx={iconButtonStyle}
              onClick={() => {
                setEditIndentData(item);
                setIsModalOpen(true);
              }}
            >
              <EditIcon />
            </IconButton>
          </Tooltip>
          <Tooltip title="Delete Indent">
            <IconButton
              sx={iconButtonStyle}
              onClick={() => {
                setIndentToDelete(item);
                setIsDeleteDialogOpen(true);
              }}
            >
              <DeleteIcon />
            </IconButton>
          </Tooltip>
        </Stack>
      ),
      attachments: (
        <>
          <Tooltip title="View Attachments">
            <span>
              <IconButton
                sx={iconButtonStyle}
                onClick={() => {
                  setIndentId(item.indentId);
                  setAttachments(item.attachments);
                  setViewAttachementDialogOpen(true);
                }}
              >
                <VisibilityIcon />
              </IconButton>
            </span>
          </Tooltip>
        </>
      ),
      approval: (
        <CustomDropdownChip
          options={statusOptions}
          value={formData[item.indentId]?.approvalStatus || ""}
          onChange={(e) => {
            handleChange(e, item.indentId);
          }}
          name="approvalStatus"
        />
      ),
      remarks: (
        <Box sx={{ minWidth: "150px" }}>
          <RemarksInputDialog
            name="remarks"
            value={formData[item.indentId]?.remarks || ""}
            onChange={(e) => handleChange(e, item.indentId)}
            remarks={item.remarkHistory || []}
            currentUser={user}
            onSendRemark={(newRemark) => handleSubmitRemark(item.indentId, newRemark)}
            onEditRemark={(remarkId, remarkText) => handleEditRemark(remarkId, remarkText)}
            icon={ChatBubbleOutline}
          />
        </Box>
      ),
      submit: (
        <CustomIconButton
          icon={ArrowCircleUp}
          label="Submit"
          disabled={(() => {
            const approvalStatus = formData[item.indentId]?.approvalStatus;
            const remarks = item.remarkHistory || [];

            const lastMyRemark = [...remarks].reverse().find((r) => r.role === user.role);

            const lastMyRemarkTime = lastMyRemark?.createdAt;

            const lastBackToMeTime = item.lastStepChangeTime;

            const addedNewRemark =
              lastMyRemarkTime && new Date(lastMyRemarkTime) > new Date(lastBackToMeTime);

            return !approvalStatus || !addedNewRemark;
          })()}
          onClick={() => handleSubmitIndent(item.indentId, item.department)}
        />
      ),
    }));

    return { columns, rows };
  };

  // Get paginated data
  const paginatedData = useMemo(() => {
    const startIndex = (currentPage - 1) * rowsPerPage;
    const endIndex = startIndex + rowsPerPage;
    if (data) {
      console.log(1, data);
      return data;
      //data?.slice(startIndex, endIndex);
    } else {
      return [];
    }
  }, [data, currentPage, rowsPerPage]);

  // Handle page change
  const handlePageChange = useCallback((event, newPage) => {
    setCurrentPage(newPage);
  }, []);

  // Handle rows per page change
  const handleRowsPerPageChange = useCallback((event) => {
    const { numericValue, resetToFirstPage } = event;

    setRowsPerPage(numericValue);
    if (resetToFirstPage) {
      setCurrentPage(1); // Reset to first page when changing page size
    }
  }, []);
  const tableData = paginatedData;


            <DataTable
              table={tableData}
              isSorted={false}
              entriesPerPage={true}
              showTotalEntries={true}
              noEndBorder
            />
        <PaginationFooter
          currentPage={currentPage}
          rowsPerPage={rowsPerPage}
          totalPages={totalPages}
          totalRecords={totalRecords}
          onPageChange={handlePageChange}
          onRowsPerPageChange={handleRowsPerPageChange}
          loading={false}
        />
