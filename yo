import { createIndentAuditTrail } from "@/services/indentAuditTrailService"; // Adjust the path as needed
import { Prisma } from "@prisma/client";
import omit from "lodash.omit";

for (const [key, value] of Object.entries(fieldsWithoutType)) {
  const oldVal = (existingIndent as any)[key];
  let mappedNewVal = value;

  // Apply mapping logic
  if (key === "department" && typeof value === "string") {
    mappedNewVal = DEPARTMENT_MAPPING[value] || value;
  } else if (key === "status" && typeof value === "string") {
    mappedNewVal = STATUS_MAPPING[value] || value;
  } else if (key === "priority" && typeof value === "string") {
    mappedNewVal = INDENT_PRIORITY_MAPPING[value] || value;
  } else if (key === "category" && typeof value === "string") {
    mappedNewVal = INDENT_CATEGORY_MAPPING[value] || value;
  } else if (key === "dueDate" && typeof value === "string") {
    mappedNewVal = new Date(value);
  }

  // Track changes only if value differs
  const isDate = oldVal instanceof Date && mappedNewVal instanceof Date;
  const isDifferent = isDate
    ? oldVal.getTime() !== mappedNewVal.getTime()
    : oldVal !== mappedNewVal;

  if (isDifferent) {
    updateData[key] = mappedNewVal;
    fieldChanges[key] = {
      from: oldVal,
      to: mappedNewVal,
    };
  }
}
export const updateIndentById = async (
  indentId: string,
  role: StepRoles,
  department: string | undefined,
  user: User,
  updatedFields: {
    type: "FIELD_UPDATE" | "WORKFLOW_UPDATE";
    department?: Department;
    description?: string;
    status?: string;
    priority?: string;
    assignedTo?: string;
    dueDate?: string;
    comments?: string;
    openStatus?: boolean;
    rejectedStatus?: boolean;
  }
) => {
  try {
    if (!indentId || !role) {
      throw new Error("indentId & role are required");
    }

    if (role !== user.role) {
      throw new Error("You are not authorized to update indents for this role");
    }

    if (
      (role === "DEPARTMENT_CHECKER" || role === "DEPARTMENT_MAKER") &&
      department !== user.department
    ) {
      throw new Error("You are not authorized to update indents for this department");
    }

    const existingIndent = await prisma.indents.findUnique({
      where: { indentId },
    });

    if (!existingIndent) {
      throw new Error("Indent not found");
    }

    const { type, ...fieldsWithoutType } = updatedFields;
    const updateData: Record<string, any> = {};
    const fieldChanges: Record<string, { from: any; to: any }> = {};
    let workflowChanges: { fromStep: number; toStep: number; rejectionReason?: string } | undefined = undefined;

    // Handle workflow update
    if (type === "WORKFLOW_UPDATE") {
      const rejectedStatus = updatedFields?.rejectedStatus ?? false;

      const { newCurrStep, newPrevStep } = stepBasedUpdateFilter(
        existingIndent.currStep,
        rejectedStatus,
        user.role,
        department
      );

      updateData.currStep = newCurrStep;
      updateData.prevStep = newPrevStep;
      updateData.rejectedStatus = rejectedStatus;

      workflowChanges = {
        fromStep: existingIndent.currStep,
        toStep: newCurrStep,
        ...(rejectedStatus ? { rejectionReason: "Rejected by user" } : {}),
      };

      switch (newCurrStep) {
        case 0:
        case 1:
          updateData.status = "PENDING";
          break;
        case 2:
        case 3:
          updateData.status = "IN_PROGRESS";
          break;
      }

      if (
        existingIndent.currStep === 4 &&
        user.role === "COMPLIANCE_CHECKER" &&
        !rejectedStatus
      ) {
        updateData.closedDate = new Date();
        updateData.status = "COMPLETED";
        updateData.openStatus = false;
      }

      updateData.lastStepChangeTime = new Date();
    }

    // Handle field update
    if (type === "FIELD_UPDATE") {
      for (const [key, newVal] of Object.entries(fieldsWithoutType)) {
        const oldVal = (existingIndent as any)[key];

        let mappedNewVal = newVal;

        if (key === "department" && typeof newVal === "string") {
          mappedNewVal = DEPARTMENT_MAPPING[newVal] || newVal;
        } else if (key === "status" && typeof newVal === "string") {
          mappedNewVal = STATUS_MAPPING[newVal] || newVal;
        } else if (key === "priority" && typeof newVal === "string") {
          mappedNewVal = INDENT_PRIORITY_MAPPING[newVal] || newVal;
        } else if (key === "category" && typeof newVal === "string") {
          mappedNewVal = INDENT_CATEGORY_MAPPING[newVal] || newVal;
        } else if (key === "dueDate" && typeof newVal === "string") {
          mappedNewVal = new Date(newVal);
        }

        if (oldVal !== mappedNewVal) {
          updateData[key] = mappedNewVal;
          fieldChanges[key] = {
            from: oldVal,
            to: mappedNewVal,
          };
        }
      }
    }

    const updatedIndent = await prisma.indents.update({
      where: { indentId },
      data: updateData,
    });

    // Trigger audit log
    await createIndentAuditTrail({
      indentId,
      actionType:
        type === "WORKFLOW_UPDATE"
          ? updatedFields.rejectedStatus
            ? "REJECTED"
            : "APPROVED"
          : "UPDATE",
      step: existingIndent.currStep,
      role: user.role,
      performedByName: user.name,
      performedByEmail: user.email,
      ...(Object.keys(fieldChanges).length > 0 ? { fieldChanges } : {}),
      ...(workflowChanges ? { workflowChanges } : {}),
    });

    return updatedIndent;
  } catch (error) {
    console.error("Error updating indent:", error);
    throw new Error("Failed to update indent");
  }
};


export const deleteIndentById = async (indentId: string, user: User) => {
  try {
    if (user.role !== "COMPLIANCE_MAKER") {
      throw new Error("Unauthorized: Only Compliance Maker can delete indents");
    }
    const existingIndent = await prisma.indents.findUnique({
      where: { indentId },
    });

    if (!existingIndent) {
      throw new Error("indent not found");
    }

    await prisma.indents.update({
      where: { indentId },
      data: { isDeleted: true },
    });
  } catch (error) {
    console.error("Error deleting indent:", error);
    throw new Error("Failed to delete indent");
  }
};

