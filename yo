import { useEffect, useState, useMemo, useCallback } from "react";
import toast from "react-hot-toast";
import { useSelector, useDispatch } from "react-redux";
import debounce from "lodash.debounce";
import { apiRequest } from "../../axios/apiRequest";
import { fetchNotifications } from "features/notificationSlice";

export const useObservationManagement = (pageType) => {
  // Common state
  const [data, setData] = useState([]);
  const [searchTerm, setSearchTerm] = useState("");
  const [filteredData, setFilteredData] = useState([]);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editObservationData, setEditObservationData] = useState(null);
  const [observationToDelete, setObservationToDelete] = useState(null);
  const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false);
  const [descriptionDialogOpen, setDescriptionDialogOpen] = useState(false);
  const [currentDescription, setCurrentDescription] = useState("");
  const [loading, setLoading] = useState(true);
  const [formData, setFormData] = useState({});
  const [viewAttachementDialogOpen, setViewAttachementDialogOpen] = useState(false);
  const [attachments, setAttachments] = useState([]);
  const [observationId, setObservationId] = useState("");

  // Pagination state
  const [currentPage, setCurrentPage] = useState(1);
  const [rowsPerPage, setRowsPerPage] = useState(5);
  const [totalRecords, setTotalRecords] = useState(1);
  const [totalPages, setTotalPages] = useState(1);

  const user = useSelector((state) => state.user.user);
  const dispatch = useDispatch();

  // API endpoint configuration based on page type
  const getApiEndpoint = useCallback(() => {
    const baseUrl = process.env.REACT_APP_BACKEND_URL;
    const role = user?.role;
    const department = user?.department;
    const pagination = `page=${currentPage}&limit=${rowsPerPage}`;

    switch (pageType) {
      case "created":
        return `${baseUrl}/api/v1/rbi-ise/${role}/created?${pagination}`;
      case "latest":
        return role === "COMPLIANCE_CHECKER"
          ? `${baseUrl}/api/v1/rbi-ise/${role}/latest?${pagination}`
          : `${baseUrl}/api/v1/rbi-ise/${role}/latest/${department}?${pagination}`;
      case "closure":
        return `${baseUrl}/api/v1/rbi-ise/${role}/closure?${pagination}`;
      case "rejected":
        return role === "COMPLIANCE_MAKER"
          ? `${baseUrl}/api/v1/rbi-ise/${role}/rejected?${pagination}`
          : `${baseUrl}/api/v1/rbi-ise/${role}/rejected/${department}?${pagination}`;
      default:
        return `${baseUrl}/api/v1/rbi-ise/${role}/created?${pagination}`;
    }
  }, [pageType, user?.role, user?.department, currentPage, rowsPerPage]);

  // Fetch data function
  const fetchData = useCallback(async () => {
    if (!user?.role) return;

    setLoading(true);
    try {
      const endpoint = getApiEndpoint();
      const response = await apiRequest("GET", endpoint);

      setData(response.data.data);
      setTotalRecords(response.data.pagination.total);
      setTotalPages(response.data.pagination.totalPages);

      // Update attachments if observationId exists
      if (observationId) {
        const updatedObservation = response.data.data.find(
          (observation) => observation.observationId === observationId
        );
        if (updatedObservation) {
          setAttachments(updatedObservation.attachments || []);
        }
      }
    } catch (error) {
      toast.error("Failed to fetch Observation");
    } finally {
      setLoading(false);
    }
  }, [getApiEndpoint, observationId, user?.role]);

  // Initial data fetch
  useEffect(() => {
    fetchData();
  }, [fetchData]);

  // Debounced search function
  const debouncedFilter = useMemo(
    () =>
      debounce((term, data) => {
        if (term) {
          const lowercasedFilter = term.toLowerCase();
          const filtered = data.filter((item) =>
            Object.keys(item).some((key) => {
              const value = item[key];
              return value !== null && value.toString().toLowerCase().includes(lowercasedFilter);
            })
          );
          setFilteredData(filtered);
        } else {
          setFilteredData(data);
        }
      }, 300),
    []
  );

  // Search effect with normalization
  useEffect(() => {
    const normalizeSearchTerm = (term) => {
      const mappings = {
        "in progress": "in_progress",
        completed: "completed",
        pending: "pending",
        "risk management": "risk_management",
        low: "low",
        medium: "medium",
        high: "high",
      };
      const lowerTerm = term.toLowerCase().trim();
      if (!lowerTerm) return "";
      if (mappings[lowerTerm]) {
        return mappings[lowerTerm];
      }
      for (const [key, value] of Object.entries(mappings)) {
        if (key.startsWith(lowerTerm) || lowerTerm.includes(key)) {
          return value;
        }
      }
      return lowerTerm;
    };

    const normalizedTerm = normalizeSearchTerm(searchTerm);

    if (!normalizedTerm) {
      setFilteredData(data);
    } else {
      debouncedFilter(normalizedTerm, data);
    }

    return () => debouncedFilter.cancel();
  }, [searchTerm, data, debouncedFilter]);

  // Common handlers
  const handleSearch = useCallback((event) => {
    setSearchTerm(event.target.value);
  }, []);

  const handleAddObservationClick = useCallback(() => {
    setEditObservationData(null);
    setIsModalOpen(true);
  }, []);

  const handleChange = useCallback((e, observationId) => {
    const { name, value } = e.target;
    setFormData((prev) => ({
      ...prev,
      [observationId]: {
        ...prev[observationId],
        [name]: value,
      },
    }));
  }, []);

  const handleObservationDelete = useCallback(async () => {
    if (!observationToDelete) return;

    try {
      const deleteObservationUrl = `${process.env.REACT_APP_BACKEND_URL}/api/v1/rbi-ise/${observationToDelete.observationId}`;
      const result = await apiRequest("DELETE", deleteObservationUrl);

      if (result.status === 200 || result.status === 204) {
        toast.success("Observation Deleted Successfully");
        setData((prev) => 
          prev.filter((observation) => observation.observationId !== observationToDelete.observationId)
        );
        fetchData();
      }
    } catch (error) {
      toast.error("Error deleting observation");
    } finally {
      setIsDeleteDialogOpen(false);
    }
  }, [observationToDelete, fetchData]);

  const handleSubmitObservation = useCallback(
    async (observationId, department) => {
      try {
        const isComplianceDepartment = department === "COMPLIANCE";
        const payload = {
          updatedFields: {
            updateType: "WORKFLOW_UPDATE",
            rejectedStatus:
              pageType === "latest" || pageType === "rejected" || pageType === "closure"
                ? formData[observationId]?.approvalStatus === "approve"
                  ? false
                  : true
                : false,
          },
        };

        const result = await apiRequest(
          "PUT",
          `${process.env.REACT_APP_BACKEND_URL}/api/v1/rbi-ise/${user.role}/${department}/${observationId}`,
          payload
        );

        if (result.status === 200 || result.status === 204) {
          // Success message logic based on page type and approval status
          if (pageType === "created") {
            toast.success("Observation Sent to Compliance Checker Successfully");
          } else if (pageType === "latest") {
            const approvalStatus = formData[observationId]?.approvalStatus;
            // Add specific success messages based on role and approval status
            if (isComplianceDepartment) {
              if (approvalStatus === "approve") {
                toast.success("Observation Sent to back to Compliance Maker for Closure Successfully");
              } else {
                toast.success("Observation Sent to back to Compliance Maker Successfully");
              }
            } else {
              if (approvalStatus === "approve") {
                if (user.role === "COMPLIANCE_CHECKER") {
                  toast.success("Observation Sent to Department Maker Successfully");
                } else if (user.role === "DEPARTMENT_MAKER") {
                  toast.success("Observation Sent to Department Checker Successfully");
                } else {
                  toast.success("Observation Sent to Compliance Maker Successfully");
                }
              } else {
                if (user.role === "COMPLIANCE_CHECKER") {
                  toast.success("Observation Sent to back to Compliance Maker Successfully");
                } else if (user.role === "DEPARTMENT_MAKER") {
                  toast.success("Observation Sent to back to Compliance Maker Successfully");
                } else {
                  toast.success("Observation Sent to back to Department Maker Successfully");
                }
              }
            }
          } else if (pageType === "rejected") {
            if (formData[observationId]?.approvalStatus === "approve") {
              if (user.role === "COMPLIANCE_MAKER") {
                toast.success("Observation Sent to Compliance Checker Successfully");
              } else if (user.role === "DEPARTMENT_MAKER") {
                toast.success("Observation Sent to Department Checker Successfully");
              } else {
                toast.success("Observation Sent Successfully");
              }
            } else {
              if (user.role === "COMPLIANCE_MAKER") {
                toast.success("Observation Sent to back to Department Maker Successfully");
              } else if (user.role === "DEPARTMENT_MAKER") {
                toast.success("Observation Sent to back to Compliance Maker Successfully");
              } else {
                toast.success("Observation Sent Successfully");
              }
            }
          } else if (pageType === "closure") {
            if (formData[observationId]?.approvalStatus === "approve") {
              if (user.role === "COMPLIANCE_MAKER") {
                toast.success("Observation Sent For Closure to Compliance Checker Successfully");
              } else if (user.role === "COMPLIANCE_CHECKER") {
                toast.success("Observation Closed Successfully");
              }
            } else if (formData[observationId]?.approvalStatus !== "approve") {
              if (user.role === "COMPLIANCE_MAKER") {
                toast.success("Observation Sent Back to Department Maker Successfully");
              } else if (user.role === "COMPLIANCE_CHECKER") {
                toast.success("Observation Sent Back to Compliance Maker Successfully");
              }
            } else {
              toast.success("Observation Sent to back to Compliance Checker Successfully");
            }
          }
        }

        fetchData();
        dispatch(fetchNotifications());
      } catch (error) {
        toast.error("An error occurred while submitting the Observation.");
      }
    },
    [pageType, formData, user.role, fetchData, dispatch]
  );

  const handleSubmitRemark = useCallback(
    async (observationId, remarkData) => {
      try {
        const result = await apiRequest(
          "POST",
          `${process.env.REACT_APP_BACKEND_URL}/api/v1/rbi-ise/remarks/${observationId}`,
          remarkData
        );

        if (result.status === 201 || result.status === 204) {
          toast.success("Observation Remark Added Successfully");
        }
        fetchData();
      } catch (error) {
        toast.error("An error occurred while submitting the Remark.");
      }
    },
    [fetchData]
  );

  const handleEditRemark = useCallback(
    async (observationId, remarkContent) => {
      try {
        const result = await apiRequest(
          "PUT",
          `${process.env.REACT_APP_BACKEND_URL}/api/v1/rbi-ise/remarks/${observationId}`,
          { remarkContent }
        );

        if (result.status === 201 || result.status === 204) {
          toast.success("Observation Remark Updated Successfully");
        }
        fetchData();
      } catch (error) {
        toast.error("An error occurred while submitting the Remark.");
      }
    },
    [fetchData]
  );

  const handleSortByStatus = useCallback(() => {
    const statusOrder = { PENDING: 1, IN_PROGRESS: 2, COMPLETED: 3 };
    const sortedData = [...data].sort((a, b) => {
      return statusOrder[a.status] - statusOrder[b.status];
    });
    setData(sortedData);
  }, [data]);

  const handlePageChange = useCallback((event, newPage) => {
    setCurrentPage(newPage);
  }, []);

  const handleRowsPerPageChange = useCallback((event) => {
    const { numericValue, resetToFirstPage } = event;
    setRowsPerPage(numericValue);
    if (resetToFirstPage) {
      setCurrentPage(1);
    }
  }, []);

  // Utility functions
  const formatDateTime = useCallback((dateString) => {
    return new Date(dateString).toLocaleString("en-GB", {
      day: "2-digit",
      month: "2-digit",
      year: "numeric",
      hour: "2-digit",
      minute: "2-digit",
      hour12: true,
    });
  }, []);

  const displayData = searchTerm ? filteredData : data;

  return {
    // State
    data,
    searchTerm,
    filteredData,
    isModalOpen,
    setIsModalOpen,
    editObservationData,
    setEditObservationData,
    observationToDelete,
    setObservationToDelete,
    isDeleteDialogOpen,
    setIsDeleteDialogOpen,
    descriptionDialogOpen,
    setDescriptionDialogOpen,
    currentDescription,
    setCurrentDescription,
    loading,
    formData,
    setFormData,
    viewAttachementDialogOpen,
    setViewAttachementDialogOpen,
    attachments,
    setAttachments,
    observationId,
    setObservationId,
    currentPage,
    rowsPerPage,
    totalRecords,
    totalPages,
    displayData,
    user,

    // Handlers
    handleSearch,
    handleAddObservationClick,
    handleChange,
    handleObservationDelete,
    handleSubmitObservation,
    handleSubmitRemark,
    handleEditRemark,
    handleSortByStatus,
    handlePageChange,
    handleRowsPerPageChange,
    fetchData,
    formatDateTime,
  };
};

import React from "react";
import { IconButton, Tooltip, Box, Stack } from "@mui/material";
import { 
  Visibility, 
  Edit, 
  Delete, 
  ArrowCircleUp, 
  ChatBubbleOutline, 
  VisibilitySharp 
} from "@mui/icons-material";
import MDTypography from "components/MDTypography";
import { CustomDropdownChip } from "layouts/resuableComponents/customDropdownChipField";
import RemarksInputDialog from "layouts/resuableComponents/RemarksInputDialog";
import CustomIconButton from "layouts/resuableComponents/CustomIconButton";
import InputWithDialog from "layouts/resuableComponents/InputWithDialog";
import { iconButtonStyle } from "layouts/resuableComponents/styles";

const statusOptions = [
  { label: "Approve", value: "approve" },
  { label: "Reject", value: "reject" },
];

export const formatObservationTableData = (
  rawData,
  pageType,
  {
    currentPage,
    rowsPerPage,
    user,
    formData,
    setCurrentDescription,
    setDescriptionDialogOpen,
    setEditObservationData,
    setIsModalOpen,
    setObservationToDelete,
    setIsDeleteDialogOpen,
    setObservationId,
    setAttachments,
    setViewAttachementDialogOpen,
    handleChange,
    handleSubmitRemark,
    handleEditRemark,
    handleSubmitObservation,
    formatDateTime,
  }
) => {
  const isComplianceRoles = user.role === "COMPLIANCE_MAKER" || user.role === "COMPLIANCE_CHECKER";
  const showDeleteAction = pageType === "created";
  const showApproval =
    pageType === "latest" ||
    pageType === "rejected" ||
    (pageType === "closure" && user.role !== "COMPLIANCE_MAKER");
  const showActions =
    pageType === "created" ||
    (pageType === "latest" && isComplianceRoles) ||
    pageType === "closure" ||
    pageType === "rejected";

  // Base columns that are common to all page types
  const baseColumns = [
    { Header: "S.No", accessor: "serialNumber", width: "5%", align: "center" },
    { Header: "Department", accessor: "department", width: "15%", align: "left" },
    { Header: "Description", accessor: "description", width: "15%", align: "left" },
    { Header: "Status", accessor: "status", width: "10%", align: "center" },
    { Header: "Priority", accessor: "priority", width: "10%", align: "center" },
    { Header: "Theme", accessor: "observationTheme", width: "10%", align: "center" },
    { Header: "Assigned To", accessor: "assignedTo", width: "10%", align: "center" },
    { Header: "Due Date", accessor: "dueDate", width: "10%", align: "center" },
    { Header: "Created At", accessor: "createdAt", width: "10%", align: "center" },
    { Header: "Comments", accessor: "comments", width: "15%", align: "left" },
  ];

  // Conditional columns based on page type
  const conditionalColumns = [];

  if (showActions) {
    conditionalColumns.push({
      Header: "Actions",
      accessor: "actions",
      width: "15%",
      align: "center",
    });
  }

  conditionalColumns.push({
    Header: "Attachments",
    accessor: "attachments",
    width: "15%",
    align: "center",
  });

  if (showApproval) {
    conditionalColumns.push({
      Header: "Approval",
      accessor: "approval",
      width: "10%",
      align: "center",
    });
  }

  conditionalColumns.push({
    Header: "Remarks",
    accessor: "remarks",
    width: "15%",
    align: "center",
  });
  conditionalColumns.push({ 
    Header: "Submit", 
    accessor: "submit", 
    width: "10%", 
    align: "center" 
  });

  const columns = [...baseColumns, ...conditionalColumns];

  const rows = rawData.map((item, index) => {
    const baseRow = {
      serialNumber: (
        <MDTypography
          variant="button"
          sx={{ color: (theme) => theme.palette.custom.text2, fontSize: "0.7rem !important" }}
        >
          {(currentPage - 1) * rowsPerPage + index + 1}
        </MDTypography>
      ),
      department: (
        <MDTypography
          variant="button"
          sx={{ color: (theme) => theme.palette.custom.text2, fontSize: "0.7rem !important" }}
        >
          {item.department.replace(/_/g, " ")}
        </MDTypography>
      ),
      description: (
        <Tooltip title="Preview Description">
          <IconButton
            sx={iconButtonStyle}
            onClick={() => {
              setCurrentDescription(item.description);
              setDescriptionDialogOpen(true);
            }}
          >
            <Visibility />
          </IconButton>
        </Tooltip>
      ),
      status: (
        <MDTypography
          variant="button"
          sx={{ color: (theme) => theme.palette.custom.text2, fontSize: "0.7rem !important" }}
        >
          {item.status.replace(/_/g, " ")}
        </MDTypography>
      ),
      priority: (
        <MDTypography
          variant="button"
          sx={{ color: (theme) => theme.palette.custom.text2, fontSize: "0.7rem !important" }}
        >
          {item.priority.replace(/_/g, " ")}
        </MDTypography>
      ),
      observationTheme: (
        <MDTypography
          variant="button"
          sx={{ color: (theme) => theme.palette.custom.text2, fontSize: "0.7rem !important" }}
        >
          {item.observationTheme ? item.observationTheme.replace(/_/g, " ") : "N/A"}
        </MDTypography>
      ),
      assignedTo: (
        <MDTypography
          variant="button"
          sx={{ color: (theme) => theme.palette.custom.text2, fontSize: "0.7rem !important" }}
        >
          {item.assignedTo}
        </MDTypography>
      ),
      dueDate: (
        <MDTypography
          variant="button"
          sx={{ color: (theme) => theme.palette.custom.text2, fontSize: "0.7rem !important" }}
        >
          {formatDateTime(item.dueDate)}
        </MDTypography>
      ),
      createdAt: (
        <MDTypography
          variant="button"
          sx={{ color: (theme) => theme.palette.custom.text2, fontSize: "0.7rem !important" }}
        >
          {formatDateTime(item.createdAt)}
        </MDTypography>
      ),
      comments: (
        <InputWithDialog
          value={item.comments}
          dialogTitle="Comments"
          dialogPlaceholder="Comments"
          cancelButtonLabel="Cancel"
          icon={Visibility}
          name="name"
          type="text"
          callOnSave={false}
          isDisabled={true}
        />
      ),
      attachments: (
        <Tooltip title="View Attachments">
          <span>
            <IconButton
              sx={iconButtonStyle}
              onClick={() => {
                setObservationId(item.observationId);
                setAttachments(item.attachments);
                setViewAttachementDialogOpen(true);
              }}
            >
              <VisibilitySharp />
            </IconButton>
          </span>
        </Tooltip>
      ),
      remarks: (
        <Box sx={{ minWidth: "150px" }}>
          <RemarksInputDialog
            name="remarks"
            value={formData[item.observationId]?.remarks || ""}
            onChange={(e) => handleChange(e, item.observationId)}
            remarks={item.remarkHistory || []}
            currentUser={user}
            onSendRemark={(newRemark) => handleSubmitRemark(item.observationId, newRemark)}
            onEditRemark={(observationId, remarkText) => handleEditRemark(observationId, remarkText)}
            icon={ChatBubbleOutline}
          />
        </Box>
      ),
    };

    // Add conditional columns based on page type
    if (showActions) {
      const actionButtons = [];

      // Edit button (always present when actions are shown)
      actionButtons.push(
        <Tooltip key="edit" title="Edit Observation Details">
          <IconButton
            sx={iconButtonStyle}
            onClick={() => {
              setEditObservationData(item);
              setIsModalOpen(true);
            }}
          >
            <Edit />
          </IconButton>
        </Tooltip>
      );

      // Delete button (only for created page)
      if (showDeleteAction) {
        actionButtons.push(
          <Tooltip key="delete" title="Delete Observation">
            <IconButton
              sx={iconButtonStyle}
              onClick={() => {
                setObservationToDelete(item);
                setIsDeleteDialogOpen(true);
              }}
            >
              <Delete />
            </IconButton>
          </Tooltip>
        );
      }

      baseRow.actions = (
        <Stack direction="row" spacing={1} justifyContent="center">
          {actionButtons}
        </Stack>
      );
    }

    // Add approval dropdown for latest page
    if (showApproval) {
      baseRow.approval = (
        <CustomDropdownChip
          options={statusOptions}
          value={formData[item.observationId]?.approvalStatus || ""}
          onChange={(e) => handleChange(e, item.observationId)}
          name="approvalStatus"
        />
      );
    }

    // Add submit button with conditional logic
    baseRow.submit = (
      <CustomIconButton
        icon={ArrowCircleUp}
        label="Submit"
        disabled={getSubmitDisabledState(item, formData, user, pageType)}
        onClick={() => handleSubmitObservation(item.observationId, item.department)}
      />
    );

    return baseRow;
  });

  return { columns, rows };
};

// Helper function to determine if submit button should be disabled
const getSubmitDisabledState = (item, formData, user, pageType) => {
  const remarks = item.remarkHistory || [];
  const lastMyRemark = [...remarks].reverse().find((r) => r.role === user.role);
  const lastMyRemarkTime = lastMyRemark?.createdAt;
  const lastBackToMeTime = item.lastStepChangeTime;
  const addedNewRemark =
    lastMyRemarkTime && new Date(lastMyRemarkTime) > new Date(lastBackToMeTime);

  if (pageType === "latest" || pageType === "rejected" || (pageType === "closure" && user.role !== "COMPLIANCE_MAKER")) {
    const approvalStatus = formData[item.observationId]?.approvalStatus;
    return !approvalStatus || !addedNewRemark;
  }

  return !addedNewRemark;
};

