import { PrismaClient } from "@prisma/client";
import { omit } from "lodash";

const prisma = new PrismaClient();

// ===================== Types =====================
type CommunicationInput = {
  commType: string;
  category: string;
  subject: string;
  refNo?: string;
  relatedIncidentId?: string;
  sentBy: string;
  sentTo: string[];
  cc?: string[];
  status: string;
  responseDueBy?: string;
  priorityLevel: string;
  summary: string;
  isConfidential: boolean;
  parentCommId?: string;
};

// ===================== Helpers =====================
const buildCreatePayload = (data: CommunicationInput) => {
  return {
    commType: data.commType,
    category: data.category,
    subject: data.subject,
    refNo: data.refNo,
    relatedIncidentId: data.relatedIncidentId,
    sentBy: data.sentBy,
    sentTo: data.sentTo,
    cc: data.cc || [],
    status: data.status,
    responseDueBy: data.responseDueBy ? new Date(data.responseDueBy) : undefined,
    priorityLevel: data.priorityLevel,
    summary: data.summary,
    isConfidential: data.isConfidential,
    parentCommId: data.parentCommId || null,
  };
};

const buildUpdatePayload = (data: Partial<CommunicationInput>) => {
  const updateData: any = {};

  if (data.commType) updateData.commType = data.commType;
  if (data.category) updateData.category = data.category;
  if (data.subject) updateData.subject = data.subject;
  if (data.refNo) updateData.refNo = data.refNo;
  if (data.relatedIncidentId) updateData.relatedIncidentId = data.relatedIncidentId;
  if (data.sentBy) updateData.sentBy = data.sentBy;
  if (data.sentTo) updateData.sentTo = data.sentTo;
  if (data.cc) updateData.cc = data.cc;
  if (data.status) updateData.status = data.status;
  if (data.responseDueBy) updateData.responseDueBy = new Date(data.responseDueBy);
  if (data.priorityLevel) updateData.priorityLevel = data.priorityLevel;
  if (data.summary) updateData.summary = data.summary;
  if (typeof data.isConfidential === 'boolean') updateData.isConfidential = data.isConfidential;
  if (data.parentCommId !== undefined) updateData.parentCommId = data.parentCommId;

  return updateData;
};

const buildFetchFilter = (type: 'inbox' | 'sent' | 'drafts' | 'thread', userId: string, threadId?: string) => {
  if (type === 'inbox') {
    return {
      status: 'Sent',
      isDeleted: false,
      OR: [{ sentTo: { has: userId } }, { cc: { has: userId } }],
    };
  }
  if (type === 'sent') {
    return {
      sentBy: userId,
      status: 'Sent',
      isDeleted: false,
    };
  }
  if (type === 'drafts') {
    return {
      sentBy: userId,
      status: 'Draft',
      isDeleted: false,
    };
  }
  if (type === 'thread' && threadId) {
    return {
      OR: [
        { commId: threadId },
        { parentCommId: threadId },
        { parentCommunication: { commId: threadId } },
      ],
    };
  }
  return {};
};

// ===================== API Functions =====================

// 1. Create Communication
export const createCommunication = async (data: CommunicationInput) => {
  try {
    const payload = buildCreatePayload(data);
    return await prisma.communication.create({ data: payload });
  } catch (error) {
    console.error("Error creating communication:", error);
    throw new Error("Failed to create communication");
  }
};

// 2. Update Communication
export const updateCommunication = async (commId: string, data: Partial<CommunicationInput>) => {
  try {
    const updatePayload = buildUpdatePayload(data);
    return await prisma.communication.update({
      where: { commId },
      data: updatePayload,
    });
  } catch (error) {
    console.error("Error updating communication:", error);
    throw new Error("Failed to update communication");
  }
};

// 3. Fetch Communication (inbox / sent / drafts / thread)
export const fetchCommunications = async (
  type: 'inbox' | 'sent' | 'drafts' | 'thread',
  userId: string,
  threadId?: string
) => {
  try {
    const where = buildFetchFilter(type, userId, threadId);
    return await prisma.communication.findMany({
      where,
      orderBy: { createdAt: 'desc' },
      include: {
        replies: true,
        attachments: { where: { isDeleted: false } },
        remarkHistory: true,
      },
    });
  } catch (error) {
    console.error("Error fetching communications:", error);
    throw new Error("Failed to fetch communications");
  }
};
