export const getIndentRepository = async (
  userRole: Position,
  userDepartment: Department,
  filters: {
    status?: "open" | "closed";
    priorityLevel?: IndentPriority;
    department?: Department;
    category?: IndentCategory;
    search?: string;
    startDate?: string;
    endDate?: string;
  },
  page: number = 1,
  pageSize: number = 10
) => {
  try {
    const offset = (page - 1) * pageSize;
    const where: any = { AND: [{ isDeleted: false }] };

    // Restrict department-level visibility
    if (
      (userRole === "DEPARTMENT_MAKER" || userRole === "DEPARTMENT_CHECKER") &&
      userDepartment
    ) {
      where.AND.push({ department: userDepartment });
    }

    // ✅ Default to open status unless explicitly 'closed'
    if (filters.status === "closed") {
      where.AND.push({ currStep: 4, rejectedStatus: false, openStatus: false });
    } else {
      where.AND.push({ openStatus: true });
    }

    // Additional filters
    if (filters.priorityLevel) {
      where.AND.push({ priority: INDENT_PRIORITY_MAPPING[filters.priorityLevel] });
    }

    if (filters.department) {
      where.AND.push({ department: DEPARTMENT_MAPPING[filters.department] });
    }

    if (filters.category) {
      where.AND.push({ category: INDENT_CATEGORY_MAPPING[filters.category] });
    }

    if (filters.startDate || filters.endDate) {
      if (filters.startDate) {
        where.AND.push({ createdAt: { gte: new Date(filters.startDate) } });
      }
      if (filters.endDate) {
        where.AND.push({ closedDate: { lte: new Date(filters.endDate) } });
      }
    }

    if (filters.search?.trim()) {
      const searchTerm = filters.search.trim();
      where.AND.push({
        OR: [
          { description: { contains: searchTerm, mode: "insensitive" } },
          { comments: { contains: searchTerm, mode: "insensitive" } },
          { indentId: { contains: searchTerm, mode: "insensitive" } },
        ],
      });
    }

    // Fetch indents and total
    const [indents, total] = await Promise.all([
      prisma.indents.findMany({
        where,
        skip: offset,
        take: pageSize,
        orderBy: { updatedAt: "desc" },
        include: {
          remarkHistory: {
            where: { isDeleted: false },
            orderBy: { createdAt: "asc" },
          },
          attachments: true,
        },
      }),
      prisma.indents.count({ where }),
    ]);

    // Process each indent and add currentStepName, currentStatus, assignedPerson
    const indentsWithMeta = await Promise.all(
      indents.map(async (indent) => {
        let assignedPerson = null;

        if (userRole === "DEPARTMENT_MAKER") {
          // ✅ Use email directly
          if (indent.assignedTo) {
            assignedPerson = { name: null, email: indent.assignedTo };
          }
        } else {
          try {
            const dept = indent.department;
            const role = dept === "Compliance" ? "COMPLIANCE_CHECKER" : "DEPARTMENT_MAKER";

            const response = await apiRequest(
              "GET",
              `${process.env.REACT_APP_BACKEND_URL}/api/admin/v1/users?department=${dept}&role=${role}`
            );

            const userList = response?.data || [];
            const userMatch = userList.find((user) => user.email === indent.assignedTo);

            if (userMatch) {
              assignedPerson = { name: userMatch.name, email: userMatch.email };
            } else if (indent.assignedTo) {
              assignedPerson = { name: null, email: indent.assignedTo };
            }
          } catch (err) {
            console.warn(`Failed to resolve assigned user for indent ${indent.indentId}`);
            if (indent.assignedTo) {
              assignedPerson = { name: null, email: indent.assignedTo };
            }
          }
        }

        return {
          ...indent,
          currentStepName: getStepName(indent.currStep),
          currentStatus: indent.openStatus ? "OPEN" : "CLOSE",
          assignedPerson,
        };
      })
    );

    return {
      success: true,
      data: indentsWithMeta,
      pagination: {
        total,
        page,
        pageSize,
        totalPages: Math.ceil(total / pageSize),
      },
      filters: {
        applied: Object.keys(filters).filter(
          (k) => filters[k as keyof typeof filters]
        ),
        search: filters.search || null,
      },
    };
  } catch (error: any) {
    console.error("Error in getIndentRepository:", error);
    throw new Error(`Indent repository fetch failed: ${error.message}`);
  }
};
