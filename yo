export const createIndent = async (
  indentData: {
    department: Department;
    description: string;
    status: IndentStatus;
    priority: IndentPriority;
    assignedTo: string;
    comments: string;
    dueDate: string;
    file?: string;
    category: IndentCategory;
  },
  role: string
) => {
  try {
    const {
      department,
      description,
      status,
      priority,
      assignedTo,
      comments,
      dueDate,
      file,
      category,
    } = indentData;

    if (role !== "COMPLIANCE_MAKER") {
      throw new Error("Unauthorized: Only Compliance Maker can create indents");
    }
    const omitData = ["updatedAt", "refreshToken"];

    const mappedStatus = STATUS_MAPPING["Pending"];
    const newIndent = await prisma.indents.create({
      data: {
        department: DEPARTMENT_MAPPING[department] as any,
        description,
        status: mappedStatus as any,
        priority: INDENT_PRIORITY_MAPPING[priority] as any,
        comments,
        assignedTo,
        ...(assignedTo ? { assignedDate: new Date() } : {}),
        dueDate: new Date(dueDate),
        ...(file ? { file } : {}),
        currStep: 0,
        prevStep: 0,
        openStatus: true,
        category: INDENT_CATEGORY_MAPPING[category] as any,
      },
    });

    const userDataTobeSent = omit(newIndent, omitData);
    return userDataTobeSent;
  } catch (error) {
    console.error("Error creating indent:", error);
    throw new Error("Failed to create indent");
  }
};

export const updateIndentById = async (
  indentId: string,
  role: StepRoles,
  department: string | undefined,
  user: User,
  updatedFields: {
    type: "FIELD_UPDATE" | "WORKFLOW_UPDATE";
    department?: Department;
    description?: string;
    status?: string;
    priority?: string;
    assignedTo?: string;
    dueDate?: string;
    comments?: string;
    openStatus?: boolean;
    rejectedStatus?: boolean;
  }
) => {
  try {
    if (!indentId || !role) {
      throw new Error("indentId & role are required");
    }

    if (role !== user.role) {
      throw new Error("You are not authorized to update indents for this role");
    }

    if (
      (role === "DEPARTMENT_CHECKER" || role === "DEPARTMENT_MAKER") &&
      department !== user.department
    ) {
      ("You are not authorized to update indents for this department");
    }

    const existingIndent = await prisma.indents.findUnique({
      where: { indentId },
    });

    if (!existingIndent) {
      throw new Error("Indent not found");
    }

    const { type, ...fieldsWithoutType } = updatedFields;
    const updateData: Record<string, any> = {};

    if (updatedFields.type === "WORKFLOW_UPDATE") {
      const rejectedStatus = updatedFields?.rejectedStatus ?? false;

      // Step update
      const { newCurrStep, newPrevStep } = stepBasedUpdateFilter(
        existingIndent.currStep,
        rejectedStatus,
        user.role,
        department
      );

      updateData.currStep = newCurrStep;
      updateData.prevStep = newPrevStep;
      updateData.rejectedStatus = rejectedStatus;

      // Determine status based on newCurrStep
      switch (newCurrStep) {
        case 0: // Compliance Maker
        case 1: // Compliance Checker
          updateData.status = "PENDING";
          break;
        case 2: // Department Maker
        case 3: // Department Checker
          updateData.status = "IN_PROGRESS";
          break;
      }

      // If final approval by Compliance Checker
      if (
        existingIndent.currStep === 4 &&
        user.role === "COMPLIANCE_CHECKER" &&
        !rejectedStatus
      ) {
        updateData.closedDate = new Date();
        updateData.status = "COMPLETED";
        updateData.openStatus = false;
      }
      updateData.lastStepChangeTime = new Date();
    }

    //  Process other user-updated fields
    for (const [key, value] of Object.entries(fieldsWithoutType)) {
      if (key === "department" && typeof value === "string") {
        updateData.department = DEPARTMENT_MAPPING[value] || value;
      } else if (key === "status" && typeof value === "string") {
        updateData.status = STATUS_MAPPING[value] || value;
      } else if (key === "priority" && typeof value === "string") {
        updateData.priority = INDENT_PRIORITY_MAPPING[value] || value;
      } else if (key === "category" && typeof value === "string") {
        updateData.priority = INDENT_CATEGORY_MAPPING[value] || value;
      } else if (key === "dueDate" && typeof value === "string") {
        updateData.dueDate = new Date(value);
      } else {
        updateData[key] = value;
      }
    }
    const updatedIndent = await prisma.indents.update({
      where: { indentId },
      data: updateData,
    });

    return updatedIndent;
  } catch (error) {
    console.error("Error updating indent:", error);
    throw new Error("Failed to update indent");
  }
};

export const deleteIndentById = async (indentId: string, user: User) => {
  try {
    if (user.role !== "COMPLIANCE_MAKER") {
      throw new Error("Unauthorized: Only Compliance Maker can delete indents");
    }
    const existingIndent = await prisma.indents.findUnique({
      where: { indentId },
    });

    if (!existingIndent) {
      throw new Error("indent not found");
    }

    await prisma.indents.update({
      where: { indentId },
      data: { isDeleted: true },
    });
  } catch (error) {
    console.error("Error deleting indent:", error);
    throw new Error("Failed to delete indent");
  }
};

